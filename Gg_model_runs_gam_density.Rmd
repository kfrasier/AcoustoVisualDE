---
title: "GoMx Risso's dolphin habitat models: Density with GAMs"
author: 
- name: Kaitlin Frasier
  affiliation: Scripps Institution of Oceanography, UC San Diego
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    theme: spacelab
    fig_caption: true 
bibliography: exportlist.bibtex
csl: plos-computational-biology.csl
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, echo = FALSE, message = FALSE, warning = FALSE}
library(mgcv)
library(MASS)
library(rgdal)
library(raster)
library(ggplot2)
library(rgeos)
library(mapview)
library(leaflet)
library(psych)
library(broom)
library(plotrix)
library(magrittr)
library(colorRamps)
library(lubridate)
library(HabitatProject)
library(lmtest)
library(zoo)
library(pracma)
library(grid)
source('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/HabitatProject/R/multiplot.R')
source('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/HabitatProject/R/plot_missingdata.R')
source('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/HabitatProject/R/plot_cleveland.R')
source('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/HabitatProject/R/plot_covarDensity.R')

options(stringsAsFactors = FALSE)
# load some preferences
load('E:/NASData/ModelData/Gg/setup_info_Gg.Rdata')
load('E:/NASData/ModelData/Gg/GgMergedData.Rdata')
outDir <- file.path('E:/NASData/ModelData',SP,'/')

```
<br>

# 1. Exploratory analysis

<br>

## 1.1 Data Inputs

NOAA SEFSC visual data goes back to 1992, but as shown in the figure below, many predictor variables are only available starting in 2003, therefore earlier visual data is currently excluded from further analyses. 

Note: Future work could use monthly climatologies (averages) so that older sightings data could be used. Some dynamic drivers like eddy and front locations would not be able to be considered using that approach.

```{r Missing data, echo = FALSE}
plotCols1 <-c(7:10,14,16,19,22,23)
covarList<-names(mergedSegments[c(plotCols1)])
varUnits <- c("SST (C)","SSH (m)",expression("Chorophyll A (mg/m"^3*")"),"MLD (m)", "Salinity (ppm)",
                 "Current Magnitude (m/sec)", "Upwelling (m/sec)", 
                 "Dist. to Anti-Cyclonic Eddy (km)","Dist. to Cyclonic Eddy (km)")

names(varUnits)<-covarList

percFilled <- plot.missingdata(mergedSegments,covarList,
                               paste0(outDir,'AcousticAndVisual_',SP),varUnits) 
percFilled <- plot.missingdata(AcOnlySegments,covarList,
                               paste0(outDir,'AcousticOnly_',SP),varUnits) 
percFilled <- plot.missingdata(VisOnlySegments,covarList,
                               paste0(outDir,'VisualOnly_',SP),varUnits) 
visDataAvailPlot <- paste0(savePath,'/VisualOnly_',SP,'_missingData.png')
```

**Visual data predictor variable availability:** 

![](`r visDataAvailPlot`)

<br> 


### 1.1.1 Splitting into testing and training sets

The data are split into training and testing sets. In this case, visual data from 2009 and acoustic data from 2013 were used only for testing. Only observations from 2003 or later were used for modeling due to covariate limitations.  

```{r test train split, echo = FALSE}
# If you decide from the missing data plots that you want to restrict years going forward:
yearListIdx = as.numeric(format(mergedSegments$date,"%Y"))
yearListIdx_AcOnly = as.numeric(format(AcOnlySegments$date,"%Y"))
yearListIdx_VisOnly = as.numeric(format(VisOnlySegments$date,"%Y"))
isVisual <- mergedSegments$Category
keepDates.train <- which(yearListIdx != 2009 & 
                           yearListIdx >= 2003 & 
                           yearListIdx != 2013)

keepDates.test <- which(yearListIdx == 2009 | 
                          yearListIdx == 2013)

keepDates_AcOnly.train <- which(yearListIdx_AcOnly != 2009 & 
                  yearListIdx_AcOnly >= 2003 & yearListIdx_AcOnly <= 2012)

keepDates_AcOnly.test <- which(yearListIdx_AcOnly == 2009 |
                                 yearListIdx_AcOnly == 2013)
keepDatesVisOnly.train <- which(yearListIdx_VisOnly != 2009 & 
                                  yearListIdx_VisOnly >= 2003)
keepDatesVisOnly.test <- which(yearListIdx_VisOnly == 2009 |
                                 yearListIdx_VisOnly == 2013)

Train_Joint.set<- mergedSegments[keepDates.train,]
Train_AcOnly.set <- AcOnlySegments[keepDates_AcOnly.train,]
Train_VisOnly.set<- VisOnlySegments[keepDatesVisOnly.train,]

Test_Joint.set<- mergedSegments[keepDates.test,]
Test_AcOnly.set<- AcOnlySegments[keepDates_AcOnly.test,]
Test_VisOnly.set<- VisOnlySegments[keepDatesVisOnly.test,]
```


<br>

### 1.1.2 Map of visual sightings data

The visual data selected for modeling are displayed on the map below. Data from 2009 were held back for testing. Blue markers indicate HARP locations.

```{r map inputs, warning = FALSE, echo = FALSE}
# Get test visual sightings
sightingsTrain <- Train_VisOnly.set[Train_VisOnly.set$Density>0,c('lat','long','date')]

sightingsTest <- Test_VisOnly.set[Test_VisOnly.set$Density>0,c('lat','long','date')]
HARPsites <- unique(Train_AcOnly.set[c('lat','long')])
pal <-colorFactor(palette = "RdYlGn", 
                  domain = c(2003,2004,2009,2012,2014))
  
map1 <- leaflet() %>%  setView(lng = -89.4, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addCircleMarkers(data = sightingsTrain, lng = ~ long, lat = ~ lat,color = ~pal(year(date)),
                 stroke = TRUE, fillOpacity = 0.8, group = 'Training Set',radius = 4)%>%
  addCircleMarkers(data = sightingsTest, lng = ~ long, lat = ~ lat,color = ~pal(year(date)),
                 stroke = TRUE, fillOpacity = 0.8, group = 'Test Set',radius = 4)%>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%
  addLegend(pal = pal,values = c(2003,2004,2009,2012,2014),title = 'Year') 

map1
```
<br>

### 1.1.3 Time series of acoustic data

The time series below show timeseries of estimated densities from passive acoustic data used for modeling (Densities were calculated following methods detailed in @RN806). Data from 2011 and 2012 were used for training, and 2013 data was held back for testing. 

<br> 

**Acoustic Timeseries:**
```{r plot timeseries, message = FALSE, echo = FALSE}
plot.timeseries(siteList,outDir,AcOnlySegments)
MCTS <- paste0(outDir,SP,'_Timeseries_Site_MC.png')
GCTS <- paste0(outDir,SP,'_Timeseries_Site_GC.png')
DTTS <- paste0(outDir,SP,'_Timeseries_Site_DT.png')
DCTS <- paste0(outDir,SP,'_Timeseries_Site_DC.png')
MPTS <- paste0(outDir,SP,'_Timeseries_Site_MP.png')
```


![](`r MCTS`)
![](`r GCTS`)
![](`r DTTS`)
![](`r DCTS`)
![](`r MPTS`)
<br> 

## 1.2 Examination of covariates

```{r remove outliers, message = FALSE, results = 'hide', echo = FALSE}
### Identify Outliers
# Replace extreme outliers (bad data) with NaNs.
outlierList <-which(Train_Joint.set$CHL< -10)
Train_Joint.set$CHL[outlierList] <- NaN 
#outlierList <-which(Train_Joint.set$FrontDist_Cayula>800000)
#Train_Joint.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Train_Joint.set$Density>100000)
Train_Joint.set$Density[outlierList] <- NaN 

outlierList <-which(Test_Joint.set$CHL< -10)
Test_Joint.set$CHL[outlierList] <- NaN 
#outlierList <-which(Test_Joint.set$FrontDist_Cayula > 800000)
#Test_Joint.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Test_Joint.set$Density>100000)
Test_Joint.set$Density[outlierList] <- NaN 


outlierList <-which(Train_AcOnly.set$CHL< -10)
Train_AcOnly.set$CHL[outlierList] <- NaN 
#outlierList <-which(Train_AcOnly.set$FrontDist_Cayula > 800000)
#Train_AcOnly.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Train_AcOnly.set$Density > 100000)
Train_AcOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Test_AcOnly.set$CHL< -10)
Test_AcOnly.set$CHL[outlierList] <- NaN 
#outlierList <-which(Test_AcOnly.set$FrontDist_Cayula>800000)
#Test_AcOnly.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Test_AcOnly.set$Density>100000)
Test_AcOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Train_VisOnly.set$CHL< -10)
Train_VisOnly.set$CHL[outlierList] <- NaN 
#outlierList <-which(Train_VisOnly.set$FrontDist_Cayula>800000)
#Train_VisOnly.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Train_VisOnly.set$Density>100000)
Train_VisOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Test_VisOnly.set$CHL<  -10)
Test_VisOnly.set$CHL[outlierList] <- NaN 
#outlierList <-which(Test_VisOnly.set$FrontDist_Cayula>800000)
#Test_VisOnly.set$FrontDist_Cayula[outlierList] <- NaN 
outlierList <-which(Test_VisOnly.set$Density>100000)
Test_VisOnly.set$Density[outlierList] <- NaN 
```

<br>

### 1.2.1 Covariate distribution check
 
<br> 

**Distributions of covariates from acoustic observations (training data only):**

```{r dot plots, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}

plot.cleveland(Train_AcOnly.set,covarList,FALSE,paste0(outDir,'AcousticOnly_',SP),varUnits)
plot.cleveland(Train_VisOnly.set,covarList,FALSE,paste0(outDir,'VisualOnly_',SP),varUnits)
plot.cleveland(Train_Joint.set,covarList,FALSE,paste0(outDir,'AcousticAndVisual_',SP),varUnits)
ACclevelandPlot<-paste0(outDir,'AcousticOnly_',
                        SP,'_clevelandDots_noTransform.png')
VisclevelandPlot<-paste0(outDir,'VisualOnly_',
                        SP,'_clevelandDots_noTransform.png')
```

![](`r ACclevelandPlot`)


<br>

**Distributions of covariates from the visual observations (training data only):**

![](`r VisclevelandPlot`)

<br>

Some of these covariates are more or less interrelated. Correlations are examined in the figure below. Numbers closer to 1 above the diagonal in the figure below represent correlation coefficients. If a pair of covariates is highly-correlated only one should typically be used in the model.

```{r correlation plots, eval = TRUE, message = FALSE, warning = FALSE, results = 'hide', echo = FALSE}
covarList2 <- c("Density","SST","SSH","CHL",
                "HYCOM_MLD","HYCOM_SALIN_0","HYCOM_MAG_0",
                "HYCOM_UPVEL_50",
                "Neg_EddyDist","Pos_EddyDist",
                "fac1","fac2","EffectiveArea")

# restrict covariates again to limited set
Train_Joint.set2<- Train_Joint.set[,covarList2]
Test_Joint.set2<- Test_Joint.set[,covarList2]
Train_AcOnly.set2<- Train_AcOnly.set[,covarList2]
Test_AcOnly.set2<- Test_AcOnly.set[,covarList2]
Train_VisOnly.set2<- Train_VisOnly.set[,covarList2]
Test_VisOnly.set2<- Test_VisOnly.set[,covarList2]

# without transform
png(paste(outDir,SP,'_correlations_noTransform.png',sep=''), width = 2000, height = 1600)
pairs.panels(Train_Joint.set2[,1:(length(covarList2)-2)], ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off()
png(paste(outDir,SP,'_correlations_noTransform_AcOnly.png',sep=''), width = 2000, height = 1600)
pairs.panels(Train_AcOnly.set2[,1:(length(covarList2)-2)], ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off()
png(paste(outDir,SP,'_correlations_noTransform_visOnly.png',sep=''), width = 2000, height = 1600)
pairs.panels(Train_VisOnly.set2[,1:(length(covarList2)-2)], ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off()
covarPlot <-paste0(outDir,SP,'_correlations_noTransform.png')
```
<br> 

**Covariate Correlations:**

![](`r covarPlot`)

<br>

### 1.2.2 Transformation of predictor variables

Some variables, including chlorophyll, mixed layer depth and distance to fronts are highly skewed and were log-transformed for input to GAMs.

```{r transform covars, message = FALSE, results = 'hide', echo = FALSE, warning = FALSE}
# covarList2 <- c("Density","SST","SSH","CHL",
#                 "HYCOM_MLD","HYCOM_SALIN_0","HYCOM_MAG_0",
#                 "HYCOM_UPVEL_50",
#                 "Neg_EddyDist", "PosEddyDist",
#                 "fac1","fac2")

transformList <- c("none","none","none","log10",
                   "log10","none","log10",
                   "none",
                   "none","none",
                   "none","none","none")

transformedCovars.train <-
  transform.covars(Train_Joint.set2,covarList2,transformList)
transformedCovars.test <- 
  transform.covars(Test_Joint.set2,covarList2,transformList)

transformedCovars_AcOnly.train <-
  transform.covars(Train_AcOnly.set2,covarList2,transformList)
transformedCovars_AcOnly.test <-
  transform.covars(Test_AcOnly.set2,covarList2,transformList)
transformedCovars_VisOnly.train <-
  transform.covars(Train_VisOnly.set2,covarList2,transformList)
transformedCovars_VisOnly.test <-
  transform.covars(Test_VisOnly.set2,covarList2,transformList)

# Generate correlation plots with transform
png(paste(outDir,SP,'_correlations_withTransform.png',sep=''), width = 2000, height = 1600)
pairs.panels(transformedCovars.train[,1:(length(covarList2)-2)], ellipses=FALSE, 
             method = "spearman",cex.cor=.75)
dev.off() 
png(paste(outDir,SP,'_correlations_withTransform_AcOnly.png',sep=''), 
    width = 2000, height = 1600)
pairs.panels(transformedCovars_AcOnly.train[,1:(length(covarList2)-2)], 
             ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off() 
png(paste(outDir,SP,'_correlations_withTransform_visOnly.png',sep=''), 
    width = 2000, height = 1600)
pairs.panels(transformedCovars_VisOnly.train[,1:(length(covarList2)-2)],
             ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off() 

```


```{r transformed dot plots, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}
# Plotting the transformed variables: 

plotCols = colnames(transformedCovars.train)[c(2:10)]
names(varUnits)<-plotCols
varUnits["log10_HYCOM_MAG_0"]<-expression("log"[10]*"(Current Magnitude (m/sec))")

varUnits["log10_HYCOM_MLD"]<- expression("log"[10]*"(MLD (m))")
varUnits["log10_CHL"] <-expression("log"[10]*"(Chorophyll A (mg/m"^3*"))")

plot.cleveland(transformedCovars.train,
               plotCols,TRUE,paste0(outDir,'AcousticAndVisual_',SP),varUnits)
plot.cleveland(transformedCovars_AcOnly.train,
               plotCols,TRUE,paste0(outDir,'AcousticOnly_',SP),varUnits)
plot.cleveland(transformedCovars_VisOnly.train,
               plotCols,TRUE,paste0(outDir,'VisualOnly_',SP),varUnits)
clevlandJointTransformed<-paste0(savePath,
                                 '/AcousticAndVisual_',SP,'_clevelandDots_withTransform.png')
```

Below, the two sets of covariates have been combined and transformed: 

![](`r clevlandJointTransformed`)

<br>

### 1.2.3 Preliminary check of predictive power 

To get an idea of the basic predictive power of these covariates, we can look at presence/absence relative to each variable. This also provides an opportunity to look at the range of values observed for each covariate in the visual and acoustic datasets. In the plots below dotted lines indicate the distribution of each covariate when `r SPLong` were present, and solid lines indicate the distribution when `r SPLong` were absent. Note that these plots do not account for effort.

```{r presence absence histograms, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}
plot.covarDensity(transformedCovars.train[,2:10],
                  colnames(transformedCovars.train[,2:10]),
                  transformedCovars.train$Density,paste0(outDir,'Both_',SP),varUnits)

plot.covarDensity(transformedCovars_AcOnly.train[,2:10],
                   colnames(transformedCovars_AcOnly.train[2:10]),
                  transformedCovars_AcOnly.train$Density,paste0(outDir,'AcousticOnly_',SP),varUnits)		

plot.covarDensity(transformedCovars_VisOnly.train[,2:10],
                  colnames(transformedCovars_VisOnly.train[,2:10]),
                  transformedCovars_VisOnly.train$Density,paste0(outDir,'VisualOnly_',SP),varUnits)
acKernels <-paste0(savePath,'/AcousticOnly_',SP,'_density_pres_abs.png')
visKernels <- paste0(savePath,'/VisualOnly_',SP,'_density_pres_abs.png')
```

<br> 

**Acoustic kernel densities:**

![](`r acKernels`)

<br>  
**Visual kernel densities:**

![](`r visKernels`)

<br>  

### 1.2.4 Estimation of relative weights

```{r load detection prob, echo = FALSE} 
visDetProbData<-paste0(outDir,SP,'sightwTrunc_GU.Rdata')
load(visDetProbData)
visDetProb <- detFun[[bestModelIdx]]$fitted[1]
visDetProbFigure <- paste0(outDir,SP,'sightwTrunc_GU.png')
```
To train the model, we need to know how much power the various data points have relative to one another. This is important because the duration, spatial coverage, and detection probabilities are quite different between the visual and acoustic data sets. If an animal is seen or heard, we know for certain that the species was present. However, if it was not heard, then it either wasn't present, or it was present but missed. 

"Zero inflation" or an excess of false zeros more common in the visual survey data because each data point represents a 10km transect section, traversed at survey speed (>10 knots) or approximately 30 minutes of observation effort. In contrast, the acoustic data are binned by day with a stationary instrument, therefore the probability of missing a group over the course of a day is lower.

For each data type, we estimated the probability of a missed detection to account for differences in zero-inflation, downweighting zeros according to the probability of a recording false negative.

The visual data represent wether or not `r SPLong` were seen during each transect segment. The probability of missing a sighting of `r SPLong` was estimated as 

\[P_{V}(detect|present) = \mu_{det} * g0\ =  `r round(visDetProb*100)/100` * `r  round(visG0*100)/100` = `r round(visDetProb* visG0*100)/100`\] 

where \mu_{det} is the mean detection probability as estimated by a model fit using the mrds package, and g0 is the probability of observing an animal on the transect line [@RN862]. We assume that reported absences are likely to be true absences `r round(visDetProb* visG0*100)` % of the time, therefore zeros are given a weight of `r round(visDetProb* visG0*100)/100` on a scale of [0,1].

The acoustic data represent presence or absence of `r SPLong` in one day bins. Given that a group of animals is present near the sensor, the probability of detecting them in a 5 minute period within a `r r_sp` km range is estimated at `r Ac_pDet`, therefore the probability of missing an encounter is 1 - `r Ac_pDet` = `r 1-Ac_pDet` [@RN806; @RN506]. Given that animals were present, the probability of missing a group for a full day (288 5-minute periods) is estimated as
\[P_{A}(detect|present) = (1-`r Ac_pDet`)^{288} \approx 1\]

Therefore we assume that there are no false negative days in the passive acoustic timeseries, and all acoustic observations are given weight = 1.


<br> 

**Best visual detection probability model for `r SPLong`:**

![](`r visDetProbFigure`)

<br>

# 2. Model Fitting

Models were fit using gam from the mgcv package in R [@RN783]. 

```{r load starting data, echo = FALSE} 
pOccur <- read.csv(pOccurenceFile, header = TRUE,na.strings=c('',' ','NA','NaN'))
```
## 2.1 Set up weighting
```{r model setup, echo = FALSE} 
# set up weighting
visDetProb <- detFun[[bestModelIdx]]$fitted[1]

transformedCovars_AcOnly.train$yAcOnly <- transformedCovars_AcOnly.train$Density
transformedCovars_VisOnly.train$yVisOnly <- transformedCovars_VisOnly.train$Density
transformedCovars.train$y <- transformedCovars.train$Density

transformedCovars_AcOnly.test$yAcOnly <- transformedCovars_AcOnly.test$Density
transformedCovars_VisOnly.test$yVisOnly <- transformedCovars_VisOnly.test$Density
transformedCovars.test$y <- transformedCovars.test$Density

# make some factors and calculate introduce column of g0 weights
joint_train_weightsG0<- array(data = 1, dim = c(length(transformedCovars.train$fac1),1))
joint_test_weightsG0<- array(data = 1, dim = c(length(transformedCovars.test$fac1),1))


for (iFac in 1:length(transformedCovars.train$fac1)) {
  if (!is.na(transformedCovars.train$fac1[iFac]) & !is.na(transformedCovars.train$Density[iFac])){
    if (transformedCovars.train$fac1[iFac]>5) {
      if (transformedCovars.train$Density[iFac]==0){
        # if it's visual data and it's a zero, adjust by g0 ie, only a X% chance it was a true zero.
        joint_train_weightsG0[iFac,1] <- visG0*visDetProb
      }
    }
  }
}

maxEffectiveAreaJoint <- max(c(transformedCovars.train$EffectiveArea,
                               transformedCovars.test$EffectiveArea))

# do additional adjustment for effective area
joint_train_weightsG0 <- joint_train_weightsG0*
                  (transformedCovars.train$EffectiveArea/maxEffectiveAreaJoint)

for (iFac in 1:length(transformedCovars.test$fac1)) {
  if (!is.na(transformedCovars.test$fac1[iFac]) & !is.na(transformedCovars.test$Density[iFac])){
    if (transformedCovars.test$fac1[iFac]>5) {
       if (transformedCovars.test$Density[iFac]==0){
        # if it's visual data and it's a zero, adjust by g0 ie, only a X% chance it was a true zero.
        joint_test_weightsG0[iFac,1] <- visG0*visDetProb
      }
    }
  }
}
# do additional adjustment for effective area
joint_test_weightsG0 <- joint_test_weightsG0*
                  (transformedCovars.test$EffectiveArea/maxEffectiveAreaJoint)


VisOnly.train_weightsG0<- array(data = 1, dim = c(length(transformedCovars_VisOnly.train$fac1),1))
VisOnly.test_weightsG0<- array(data = 1, dim = c(length(transformedCovars_VisOnly.test$fac1),1))

for (iFac in 1:length(transformedCovars_VisOnly.train$fac1)) {
  if (!is.na(transformedCovars_VisOnly.train$Density[iFac]) & 
       transformedCovars_VisOnly.train$Density[iFac]==0){
    # if it's visual data and it's a zero, adjust by g0 ie, only a X% chance it was a true zero.
    VisOnly.train_weightsG0[iFac,1] <- visG0*visDetProb
  }
}

maxEffectiveAreaVis <- max(c(transformedCovars_VisOnly.train$EffectiveArea,
                               transformedCovars_VisOnly.test$EffectiveArea))
# do additional adjustment for effective area
VisOnly.train_weightsG0 <- VisOnly.train_weightsG0*
                  (transformedCovars_VisOnly.train$EffectiveArea/maxEffectiveAreaVis)

for (iFac in 1:length(transformedCovars_VisOnly.test$fac1)) {
  if (!is.na(transformedCovars_VisOnly.test$Density[iFac]) & 
      transformedCovars_VisOnly.test$Density[iFac]==0){
    # if it's visual data and it's a zero, adjust by g0 ie, only a X% chance it was a true zero.
    VisOnly.test_weightsG0[iFac,1] <- visG0*visDetProb
  }
}

# do additional adjustment for effective area
VisOnly.test_weightsG0 <- VisOnly.test_weightsG0*
                  (transformedCovars_VisOnly.test$EffectiveArea/maxEffectiveAreaVis)

# Remove NaNs
goodData_Ac <- which(!is.na(rowSums(transformedCovars_AcOnly.train)))
AcOnly.train.NoNa <- transformedCovars_AcOnly.train[goodData_Ac,]

goodData_Vis <- which(!is.na(rowSums(transformedCovars_VisOnly.train)))
VisOnly.train.NoNa <- transformedCovars_VisOnly.train[goodData_Vis,]

goodData_Joint <- which(!is.na(rowSums(transformedCovars.train)))
Joint.train.NoNa <- transformedCovars.train[goodData_Joint,]


goodData_Ac_test <- which(!is.na(rowSums(transformedCovars_AcOnly.test)))
AcOnly.test.NoNa <- transformedCovars_AcOnly.test[goodData_Ac_test,]

goodData_Vis_test <- which(!is.na(rowSums(transformedCovars_VisOnly.test)))
VisOnly.test.NoNa <- transformedCovars_VisOnly.test[goodData_Vis_test,]

goodData_Joint_test <- which(!is.na(rowSums(transformedCovars.test)))
Joint.test.NoNa <- transformedCovars.test[goodData_Joint_test,]

kVal = 5
gam_full_AcOnly<- NULL
gam_full_VisOnly<- NULL
gam_full_Joint<- NULL



# save ranges of each scaled covariate in training set (max and min)
JointRangesMax <- apply(transformedCovars.train, MARGIN = 2, 
                        function(x) max(x, na.rm=TRUE))
JointRangesMin <- apply(transformedCovars.train, MARGIN = 2, 
                        function(x) min(x, na.rm=TRUE))

AcOnlyRangesMax <- apply(transformedCovars_AcOnly.train, MARGIN = 2,
                         function(x) max(x, na.rm=TRUE))
AcOnlyRangesMin <- apply(transformedCovars_AcOnly.train, MARGIN = 2,
                         function(x) min(x, na.rm=TRUE))

VisOnlyRangesMax <- apply(transformedCovars_VisOnly.train, MARGIN = 2,
                          function(x) max(x, na.rm=TRUE))
VisOnlyRangesMin <- apply(transformedCovars_VisOnly.train, MARGIN = 2,
                          function(x) min(x, na.rm=TRUE))
```

## 2.2 Run GAMs

Run GAMs on acoustic-only, visual-only, and joint acoustic/visual datasets.

```{r AcOnly model, eval = TRUE, echo = TRUE}
varNames <- names(transformedCovars_AcOnly.train)
varNamesFormula <- varNames[2:10]
formulaAcOnly_allVars <-paste('s(', varNamesFormula, ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaAcOnly_allVars <- as.formula(paste('yAcOnly ~',formulaAcOnly_allVars))
gam_full_AcOnly <- gam(formulaAcOnly_allVars,
                               data = transformedCovars_AcOnly.train,
                               na.action = na.omit,family = tw())
```


```{r VisOnly model, eval = TRUE, include = TRUE, echo = TRUE} 
formulaVisOnly_allVars <-paste('s(', varNamesFormula, ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaVisOnly_allVars <- as.formula(paste('yVisOnly ~',formulaVisOnly_allVars))
gam_full_VisOnly <- gam(formulaVisOnly_allVars,
                               data = transformedCovars_VisOnly.train,
                               na.action = na.omit,
                               family = Tweedie(p = 1.5, link = log),
                               weights = VisOnly.train_weightsG0)
```

```{r Joint model, eval = TRUE, include = TRUE, echo = TRUE} 
formulaJoint_allVars <-paste('s(', varNamesFormula, ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaJoint_allVars <- as.formula(paste('y ~',formulaJoint_allVars))
gam_full_Joint <- gam(formulaJoint_allVars,
                        data = transformedCovars.train, 
                        weights = joint_train_weightsG0,
                        na.action = na.omit,
                        family = Tweedie(p = 1.5, link = log))
```



```{r save models, eval = TRUE, echo = FALSE, include = FALSE}
# Save models if re-calculating everything
save(gam_full_AcOnly,file = paste(outDir,SP,'_AcOnly_tw_GAMs_Density.Rdata',sep=''))
save(gam_full_VisOnly,file = paste(outDir,SP,'_VisOnly_tw_GAMs_Density.Rdata',sep=''))
save(gam_full_Joint,file = paste(outDir,SP,'_Joint_tw_GAMs_Density.Rdata',sep=''))
```

```{r load models, eval = TRUE, echo = FALSE, include = FALSE}
# alternative if models are already calculated
load(paste(outDir,SP,'_AcOnly_tw_GAMs_Density.Rdata',sep=''))
load(paste(outDir,SP,'_VisOnly_tw_GAMs_Density.Rdata',sep=''))
load(paste(outDir,SP,'_Joint_tw_GAMs_Density.Rdata',sep=''))
```

<br>

# 3. Model Summaries

Model summaries show that some terms were not significant.

## 3.1 Acoustic-only model

Model summary:

```{r AcOnly unpruned model summary, echo = FALSE}
AcOnlySummary <- summary(gam_full_AcOnly)
# AcOnlySummary
significantPvals_AcOnly <- which(AcOnlySummary$s.pv<=.05)

# rerun model with only significant predictors
formulaAcOnly_prunedVars <-paste('s(', varNamesFormula[significantPvals_AcOnly], ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaAcOnly_prunedVars <- as.formula(paste('yAcOnly ~',formulaAcOnly_prunedVars))
AcOnly_model <- gam(formulaAcOnly_prunedVars,
                               data = transformedCovars_AcOnly.train,
                               na.action = na.omit,family = tw())

summary(AcOnly_model)
```
<br> 

Smooths of predictor variables:

```{r AcOnly model plots, echo = FALSE}
nTerms <- size(AcOnly_model$smooth,2)
par(mfrow = c(ceil(nTerms/3),3),mar = c(4,2,1,1))
for  (i in 1:nTerms) {
  plot(AcOnly_model,select = i,
       cex.lab = 1.3,cex.axis = 1.1,scale=0,xlab = varUnits[i], ylab = "")
}
```
<br>

Plot of residuals:

```{r AcOnly model residuals, echo = FALSE}
plot(residuals.gam(AcOnly_model))
# gam.check(AcOnly_gam_pruned_TF_best)
```
<br>

## 3.2 Visual-only model


Model summary:

```{r VisOnly model summary, echo = FALSE}
VisOnlySummary <- summary(gam_full_VisOnly)
# VisOnlySummary
significantPvals_VisOnly <- which(VisOnlySummary$s.pv<=.05)

# rerun model with only significant predictors
formulaVisOnly_prunedVars <-paste('s(', varNamesFormula[significantPvals_VisOnly], ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaVisOnly_prunedVars <- as.formula(paste('yVisOnly ~',formulaVisOnly_prunedVars))
VisOnly_model <- gam(formulaVisOnly_prunedVars,
                               data = transformedCovars_VisOnly.train,
                               family = Tweedie(p = 1.5, link = log),
                               weights = VisOnly.train_weightsG0)
summary(VisOnly_model)

```

Smooths of predictor variables:

```{r VisOnly model plots, echo = FALSE}
nTerms <- size(VisOnly_model$smooth,2)
par(mfrow = c(ceil(nTerms/3),3),mar = c(4,2,1,1))
for  (i in 1:nTerms) {
  plot(VisOnly_model,select = i,
       cex.lab = 1.3,cex.axis = 1.1,scale=0,xlab = varUnits[i], ylab = "")
}
```

Plot of residuals:

```{r VisOnly model residuals, echo = FALSE}
plot(residuals.gam(VisOnly_model))
# gam.check(VisOnly_gam_pruned_TF_best)
```

<br>

## 3.3 Joint model

Model summary:

```{r Joint model summary,echo = FALSE}
JointSummary <- summary(gam_full_Joint)
# JointSummary
significantPvals_Joint <- which(JointSummary$s.pv<=.05)

# rerun model with only significant predictors
formulaJoint_prunedVars <-paste('s(', varNamesFormula[significantPvals_Joint], ", bs = 'ts', k = kVal)", sep = "", collapse = ' + ')
formulaJoint_prunedVars <- as.formula(paste('y ~',formulaJoint_prunedVars))
Joint_model <- gam(formulaJoint_prunedVars,
                        data = transformedCovars.train, 
                        weights = joint_train_weightsG0,
                        na.action = na.omit,
                        family = Tweedie(p = 1.5, link = log))
summary(Joint_model)
```

Smooths of predictor variables:

```{r Joint model plots,echo = FALSE}
nTerms <- size(Joint_model$smooth,2)
par(mfrow = c(ceil(nTerms/3),3),mar = c(4,2,1,1))
for  (i in 1:nTerms) {
  plot(Joint_model,select = i,
       cex.lab = 1.3,cex.axis = 1.1,scale=0,xlab = varUnits[i], ylab = "")
}
```
<br>

Plot of residuals:

```{r Joint model residuals, echo = FALSE}
plot(residuals.gam(Joint_model))
# gam.check(gam_pruned_TF_best)
```

<br> 

# 4. Model Predictions

## 4.1 Temporal predictions

Predictions were made on the acoustic test dataset, and compared with actual observations for 2013. The predicted density of animals at each site was compared with the estimated daily density from the pasive acoustic record. 

<br>

### 4.1.1 Acoustic-only prediction
```{r Ac Temporal Predict, echo = FALSE, warning = FALSE, message = FALSE}
# Predict on acoustic test data, using acoustic only model for comparison...
compAcSet_MC <- which((AcOnly.test.NoNa$fac2)==5)
compAcSet_GC <- which((AcOnly.test.NoNa$fac2)==10)
compAcSet_DT <- which((AcOnly.test.NoNa$fac2)==15 |
                        (AcOnly.test.NoNa$fac2)==16)
compAcSet_DC <- which((AcOnly.test.NoNa$fac2)==21 |
                        (AcOnly.test.NoNa$fac2)==22)
compAcSet_MP <- which((AcOnly.test.NoNa$fac2)==26)

# Predict in time
dateTicks = as.POSIXct(c('2013-01-01 GMT','2013-04-01 GMT',
                         '2013-07-01 GMT','2013-10-01 GMT',
                         '2014-01-01 GMT'))
dateLabels = c('Jan. 2013','Apr. 2013','Jul. 2013','Oct 2013','Jan. 2014')
predAcOnly_MC <- predict.gam(AcOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_MC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predAcOnly_GC <- predict.gam(AcOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_GC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predAcOnly_DT <- predict.gam(AcOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_DT,],
                            type = 'response',na.action = na.pass,se.fit=TRUE)
predAcOnly_DC <- predict.gam(AcOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_DC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predAcOnly_MP <- predict.gam(AcOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_MP,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
# occurIdx = which(as.POSIXct(pOccur[,1])>='2013-01-01' & as.POSIXct(pOccur[,1])<'2014-01-01')


AcOnly_predictionSet <- data.frame(unique(Test_AcOnly.set$date[goodData_Ac_test]))
AcOnlyGoodTimes <-  Test_AcOnly.set$date[goodData_Ac_test]
colnames(AcOnly_predictionSet) <-"date"
AcOnly_predictionSet$MC <- NA
AcOnly_predictionSet$predSd_MC <- NA
AcOnly_predictionSet$testObs_MC <-NA
AcOnly_predictionSet$testObs_MC_smooth <- NA
MC_times <- AcOnlyGoodTimes[compAcSet_MC]
m1 <- match(MC_times,AcOnly_predictionSet$date)
AcOnly_predictionSet$MC[m1] <-predAcOnly_MC$fit
AcOnly_predictionSet$predSd_MC[m1] <- predAcOnly_MC$se.fit
AcOnly_predictionSet$testObs_MC[m1] <- Test_AcOnly.set$Density[compAcSet_MC]
AcOnly_predictionSet$testObs_MC_smooth <- rollmean(AcOnly_predictionSet$testObs_MC,k = 7,fill=NA)

AcOnly_predictionSet$GC <- NA
AcOnly_predictionSet$predSd_GC <- NA
AcOnly_predictionSet$testObs_GC <-NA
GC_times <- AcOnlyGoodTimes[compAcSet_GC]
m2 <- match(GC_times,AcOnly_predictionSet$date)
AcOnly_predictionSet$GC[m2] <-predAcOnly_GC$fit
AcOnly_predictionSet$predSd_GC[m2] <- predAcOnly_GC$se.fit
AcOnly_predictionSet$testObs_GC[m2] <- Test_AcOnly.set$Density[compAcSet_GC]
AcOnly_predictionSet$testObs_GC_smooth <- rollmean(AcOnly_predictionSet$testObs_GC,k=7,fill=NA)

AcOnly_predictionSet$DT <- NA
AcOnly_predictionSet$predSd_DT <- NA
AcOnly_predictionSet$testObs_DT <-NA
DT_times <- AcOnlyGoodTimes[compAcSet_DT]
m3 <- match(DT_times,AcOnly_predictionSet$date)
AcOnly_predictionSet$DT[m3] <- predAcOnly_DT$fit
AcOnly_predictionSet$predSd_DT[m3] <- predAcOnly_DT$se.fit
AcOnly_predictionSet$testObs_DT[m3] <- Test_AcOnly.set$Density[compAcSet_DT]
AcOnly_predictionSet$testObs_DT_smooth <- rollmean(AcOnly_predictionSet$testObs_DT,k=7,fill=NA)

AcOnly_predictionSet$DC <- NA
AcOnly_predictionSet$predSd_DC <- NA
AcOnly_predictionSet$testObs_DC <-NA
DC_times <- AcOnlyGoodTimes[compAcSet_DC]
m4 <- match(DC_times,AcOnly_predictionSet$date)
AcOnly_predictionSet$DC[m4] <- predAcOnly_DC$fit
AcOnly_predictionSet$predSd_DC[m4] <- predAcOnly_DC$se.fit
AcOnly_predictionSet$testObs_DC[m4] <- Test_AcOnly.set$Density[compAcSet_DC]
AcOnly_predictionSet$testObs_DC_smooth <- rollmean(AcOnly_predictionSet$testObs_DC,k=7,fill=NA)

AcOnly_predictionSet$MP <- NA
AcOnly_predictionSet$predSd_MP <- NA
AcOnly_predictionSet$testObs_MP <-NA
MP_times <- AcOnlyGoodTimes[compAcSet_MP]
m5 <- match(MP_times,AcOnly_predictionSet$date)
AcOnly_predictionSet$MP[m5] <- predAcOnly_MP$fit
AcOnly_predictionSet$predSd_MP[m5] <- predAcOnly_MP$se.fit
AcOnly_predictionSet$testObs_MP[m5] <- Test_AcOnly.set$Density[compAcSet_MP]
AcOnly_predictionSet$testObs_MP_smooth <- rollmean(AcOnly_predictionSet$testObs_MP,k=7,fill=NA)

AcOnly_predictionSet$Legend1 <- "Observations"
AcOnly_predictionSet$StDev <- "Std. Error"
AcOnly_predictionSet$Legend <- "Predictions"

```

**Predicted and observed densities at passive acoustic monitoring sites using the acoustic-only model:**

```{r,fig.height = 10, fig.width = 7, message = FALSE, warning = FALSE, echo = FALSE}
# par(mfrow = c(5,1),oma=c(3,0,5,0)),colour="#000099",colour="#CC0000"
mcLabel <- grobTree(textGrob("MC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
gcLabel <- grobTree(textGrob("GC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
dtLabel <- grobTree(textGrob("DT", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
dcLabel <- grobTree(textGrob("DC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
mpLabel <- grobTree(textGrob("MP", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))

p1_Ac <- ggplot() +
  geom_ribbon(data = AcOnly_predictionSet,
            aes(x = date, ymax = predSd_MC + MC, ymin = pmax(MC - predSd_MC,0)), fill = "lightgray") +
  geom_area(data = AcOnly_predictionSet, 
            aes(x = date, y = pmax(MC - predSd_MC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MC_smooth,color = Legend1))+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y = MC, color = Legend))+
  labs(y = "Density (/1000km^2)", x = "")+
  scale_color_manual("",values= c("gray48","#009999"))+
  theme_bw()+theme(legend.position = c(0.9, 0.8),legend.title=element_blank(),
                   legend.margin=margin(c(1,5,5,5)))+
  annotation_custom(mcLabel)#+ylim(c(0,.6))

p2_Ac <- ggplot() +
  geom_ribbon(data = AcOnly_predictionSet, 
            aes(x = date, ymax = predSd_GC + GC, ymin = pmax(GC - predSd_GC,0)), fill = "lightgray") +
  geom_area(data = AcOnly_predictionSet, 
            aes(x = date, y = pmax(GC - predSd_GC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_GC_smooth,color = Legend1))+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=GC, color = Legend))+
  scale_color_manual("",values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+annotation_custom(gcLabel)

p3_Ac <- ggplot() +
  geom_ribbon(data = AcOnly_predictionSet, 
            aes(x = date, ymax = predSd_DT + DT, ymin = pmax(DT - predSd_DT,0)), fill = "lightgray") +
  geom_area(data = AcOnly_predictionSet, 
            aes(x = date, y = pmax(DT - predSd_DT,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DT_smooth,color = Legend1))+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=DT, color = Legend)) +
  scale_color_manual("",values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+annotation_custom(dtLabel)

p4_Ac <- ggplot() +
  geom_ribbon(data = AcOnly_predictionSet,
            aes(x = date, ymax = predSd_DC + DC, ymin = pmax(DC - predSd_DC,0)), fill = "lightgray") +
  geom_area(data = AcOnly_predictionSet,
            aes(x = date, y = pmax(DC - predSd_DC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DC_smooth, color = Legend1))+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=DC, color = Legend)) +
  scale_color_manual("",values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+annotation_custom(dcLabel)

p5_Ac <- ggplot() +
  geom_ribbon(data = AcOnly_predictionSet, 
            aes(x = date, ymax = predSd_MP + MP, ymin = pmax(MP - predSd_MP,0)), fill = "lightgray") +
  geom_area(data = AcOnly_predictionSet, 
            aes(x = date, y = pmax(MP - predSd_MP,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MP_smooth,color = Legend1))+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=MP, color = Legend)) +
  scale_color_manual("",values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "Date")+theme_bw()+
  theme(legend.position="none")+annotation_custom(mpLabel)

multiplot(p1_Ac, p2_Ac, p3_Ac, p4_Ac, p5_Ac, cols=1)

```
<br>

### 4.1.2 Visual-only prediction

```{r Vis Temporal Predict, warning = FALSE, echo = FALSE}
# Confusing, but acoustic only predictors are passed in to since
# we're predicting on the acoustic timeseries.
# Predict in time

predVisOnly_MC <- predict.gam(VisOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_MC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predVisOnly_GC <- predict.gam(VisOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_GC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predVisOnly_DT <- predict.gam(VisOnly_model,
                             transformedCovars_AcOnly.test[compAcSet_DT,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predVisOnly_DC <- predict.gam(VisOnly_model,
                              transformedCovars_AcOnly.test[compAcSet_DC,],
                              type = 'response',na.action = na.pass,se.fit=TRUE)
predVisOnly_MP <- predict.gam(VisOnly_model,
                              transformedCovars_AcOnly.test[compAcSet_MP,],
                              type = 'response',na.action = na.pass,se.fit=TRUE)

occurIdx = which(as.POSIXct(pOccur[,1])>='2013-01-01' & as.POSIXct(pOccur[,1])<'2014-01-01')


VisOnly_predictionSet <- data.frame(unique(Test_AcOnly.set$date))
colnames(VisOnly_predictionSet) <-"date"

VisOnly_predictionSet$MC <- NA
VisOnly_predictionSet$predSd_MC <- NA
m1 <- match(MC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$MC[m1] <-predVisOnly_MC$fit
VisOnly_predictionSet$predSd_MC[m1] <- predVisOnly_MC$se.fit

VisOnly_predictionSet$GC <- NA
VisOnly_predictionSet$predSd_GC <- NA
m2 <- match(GC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$GC[m2] <-predVisOnly_GC$fit
VisOnly_predictionSet$predSd_GC[m2] <- predVisOnly_GC$se.fit

VisOnly_predictionSet$DT <- NA
VisOnly_predictionSet$predSd_DT <- NA
m3 <- match(DT_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$DT[m3] <-predVisOnly_DT$fit
VisOnly_predictionSet$predSd_DT[m3] <- predVisOnly_DT$se.fit

VisOnly_predictionSet$DC <- NA
VisOnly_predictionSet$predSd_DC <- NA
m4 <- match(DC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$DC[m4] <-predVisOnly_DC$se.fit
VisOnly_predictionSet$predSd_DC[m4] <- predVisOnly_DC$se.fit

VisOnly_predictionSet$MP <- NA
VisOnly_predictionSet$predSd_MP <- NA
m5 <- match(MP_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$MP[m5] <-predVisOnly_MP$se.fit
VisOnly_predictionSet$predSd_MP[m5] <- predVisOnly_MP$se.fit

VisOnly_predictionSet$Legend <- "Predictions"
```

**Predicted and observed densities at passive acoustic monitoring sites using the visual-only model:**

```{r,fig.height = 10, fig.width = 7, message = FALSE, warning = FALSE, echo = FALSE}
# par(mfrow = c(5,1),oma=c(3,0,5,0)),colour="#000099",colour="#CC0000"
p1_Vis <- ggplot() +
  geom_ribbon(data = VisOnly_predictionSet, 
            aes(x = date, ymax = predSd_MC + MC,ymin = pmax(MC - predSd_MC,0)), fill = "lightgray") +
  geom_area(data = VisOnly_predictionSet, 
            aes(x = date, y = pmax(MC - predSd_MC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MC_smooth,color = Legend1))+
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=MC, color = Legend)) +
  labs(y = "Density (/1000km^2)", x = "")+
  scale_color_manual(values= c("gray48","#009999"))+theme_bw()+
  theme(legend.position = c(0.9, 0.8),legend.title=element_blank(),
                   legend.margin=margin(c(1,5,5,5)))+
  annotation_custom(mcLabel)

p2_Vis <- ggplot() +
  geom_ribbon(data = VisOnly_predictionSet, 
            aes(x = date, ymax = predSd_GC + GC,ymin = pmax(GC - predSd_GC,0)), fill = "lightgray") +
  geom_area(data = VisOnly_predictionSet, 
            aes(x = date, y = pmax(GC - predSd_GC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_GC_smooth,color = Legend1))+
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=GC, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(gcLabel)

p3_Vis <- ggplot() +
  geom_ribbon(data = VisOnly_predictionSet, 
            aes(x = date, ymax = predSd_DT + DT,ymin = pmax(DT - predSd_DT,0)), fill = "lightgray") +
  geom_area(data = VisOnly_predictionSet, 
            aes(x = date, y = pmax(DT - predSd_DT,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DT_smooth,color = Legend1))+
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=DT, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(dtLabel)

p4_Vis <- ggplot() +
  geom_ribbon(data = VisOnly_predictionSet, 
            aes(x = date, ymax = predSd_DC + DC,ymin = pmax(DC - predSd_DC,0)), fill = "lightgray") +
  geom_area(data = VisOnly_predictionSet,
            aes(x = date, y = pmax(DC - predSd_DC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DC_smooth,color = Legend1))+
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=DC, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(dcLabel)

p5_Vis <- ggplot() +
  geom_ribbon(data = VisOnly_predictionSet, 
            aes(x = date, ymax = predSd_MP + MP,ymin = pmax(MP - predSd_MP,0)), fill = "lightgray") +
  geom_area(data = VisOnly_predictionSet, 
            aes(x = date, y = pmax(MP - predSd_MP,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MP_smooth,color = Legend1))+
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=MP, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(mpLabel)

multiplot(p1_Vis, p2_Vis, p3_Vis, p4_Vis, p5_Vis, cols=1)

```

<br>

### 4.1.3 Joint prediction

```{r Combo Temporal Predict,fig.height = 10, fig.width = 7, warning = FALSE, echo = FALSE}
predJoint_MC <- predict.gam(Joint_model,
                             transformedCovars_AcOnly.test[compAcSet_MC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predJoint_GC <- predict.gam(Joint_model,
                             transformedCovars_AcOnly.test[compAcSet_GC,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predJoint_DT <- predict.gam(Joint_model,
                             transformedCovars_AcOnly.test[compAcSet_DT,],
                             type = 'response',na.action = na.pass,se.fit=TRUE)
predJoint_DC <- predict.gam(Joint_model,
                              transformedCovars_AcOnly.test[compAcSet_DC,],
                              type = 'response',na.action = na.pass,se.fit=TRUE)
predJoint_MP <- predict.gam(Joint_model,
                              transformedCovars_AcOnly.test[compAcSet_MP,],
                              type = 'response',na.action = na.pass,se.fit=TRUE)


Joint_predictionSet <- data.frame(unique(Test_AcOnly.set$date))
colnames(Joint_predictionSet) <-"date"
Joint_predictionSet$MC <- NA
Joint_predictionSet$predSd_MC <- NA
m1 <- match(MC_times,Joint_predictionSet$date)
Joint_predictionSet$MC[m1] <-predJoint_MC$fit
Joint_predictionSet$predSd_MC[m1] <- predJoint_MC$se.fit

Joint_predictionSet$GC <- NA
Joint_predictionSet$predSd_GC <- NA
m2 <- match(GC_times,Joint_predictionSet$date)
Joint_predictionSet$GC[m2] <-predJoint_GC$fit
Joint_predictionSet$predSd_GC[m2] <- predJoint_GC$se.fit

Joint_predictionSet$DT <- NA
Joint_predictionSet$predSd_DT <- NA
m3 <- match(DT_times,Joint_predictionSet$date)
Joint_predictionSet$DT[m3] <-predJoint_DT$fit
Joint_predictionSet$predSd_DT[m3] <- predJoint_DT$se.fit

Joint_predictionSet$DC <- NA
Joint_predictionSet$predSd_DC <- NA
m4 <- match(DC_times,Joint_predictionSet$date)
Joint_predictionSet$DC[m4] <-predJoint_DC$fit
Joint_predictionSet$predSd_DC[m4] <- predJoint_DC$se.fit

Joint_predictionSet$MP <- NA
Joint_predictionSet$predSd_MP <- NA
m5 <- match(MP_times,Joint_predictionSet$date)
Joint_predictionSet$MP[m5] <-predJoint_MP$fit
Joint_predictionSet$predSd_MP[m5] <- predJoint_MP$se.fit

Joint_predictionSet$Legend1 <- "Observations"
Joint_predictionSet$StDev <- "Std. Error"
Joint_predictionSet$Legend <- "Predictions"
```

**Predicted and observed encounter probabilities at passive acoustic monitoring sites using the joint model:**

```{r,fig.height = 10, fig.width = 7, message = FALSE, warning = FALSE, echo = FALSE}
# par(mfrow = c(5,1),oma=c(3,0,5,0)),colour="#000099",colour="#CC0000"
p1 <- ggplot() +
  geom_ribbon(data = Joint_predictionSet, 
            aes(x = date, ymax = predSd_MC + MC,ymin = pmax(MC - predSd_MC,0)), fill = "lightgray") +
  geom_area(data = Joint_predictionSet, 
            aes(x = date, y = pmax(MC - predSd_MC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MC_smooth,color = Legend1))+
  geom_line(data = Joint_predictionSet,
            aes(x=date, y=MC, color = Legend)) +
  labs(y = "Density (/1000km^2)", x = "")+
  scale_color_manual(values= c("gray48","#009999"))+theme_bw()+
  theme(legend.position = c(0.9, 0.8),legend.title=element_blank(),
                   legend.margin=margin(c(1,5,5,5)))+
  annotation_custom(mcLabel)

p2 <- ggplot() +
  geom_ribbon(data = Joint_predictionSet, 
            aes(x = date, ymax = predSd_GC + GC,ymin = pmax(GC - predSd_GC,0)), fill = "lightgray") +
  geom_area(data = Joint_predictionSet, 
            aes(x = date, y = pmax(GC - predSd_GC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_GC_smooth,color = Legend1))+
  geom_line(data = Joint_predictionSet,
            aes(x=date, y=GC, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(gcLabel)

p3 <- ggplot() +
  geom_ribbon(data = Joint_predictionSet, 
            aes(x = date, ymax = predSd_DT + DT,ymin = pmax(DT - predSd_DT,0)), fill = "lightgray") +
  geom_area(data = Joint_predictionSet, 
            aes(x = date, y = pmax(DT - predSd_DT,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DT_smooth,color = Legend1))+
  geom_line(data = Joint_predictionSet,
            aes(x=date, y=DT, color = Legend)) +
  scale_color_manual(values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position="none")+
  annotation_custom(dtLabel)

p4 <- ggplot() +
  geom_ribbon(data = Joint_predictionSet, 
            aes(x = date, ymax = predSd_DC + DC,ymin = pmax(DC - predSd_DC,0)), fill = "lightgray") +
  geom_area(data = Joint_predictionSet, 
            aes(x = date, y = pmax(DC - predSd_DC,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_DC_smooth,color = Legend1))+
  geom_line(data = Joint_predictionSet,
            aes(x = date, y = DC, color = Legend)) +
  scale_color_manual("",values= c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "")+theme_bw()+
  theme(legend.position = "none")+
  annotation_custom(dcLabel)

p5 <- ggplot() +
  geom_ribbon(data = Joint_predictionSet, 
            aes(x = date, ymax = predSd_MP + MP,ymin = pmax(MP - predSd_MP,0)), fill = "lightgray") +
  geom_area(data = Joint_predictionSet, 
            aes(x = date, y = pmax(MP - predSd_MP,0)), fill = "white") +
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = testObs_MP_smooth, color = Legend1))+
  geom_line(data = Joint_predictionSet,
            aes(x = date, y = MP, color = Legend))+
  scale_color_manual("",values = c("gray48","#009999"))+
  labs(y = "Density (/1000km^2)", x = "Date")+theme_bw()+
  theme(legend.position = "none")+
  annotation_custom(mpLabel)

multiplot(p1, p2, p3, p4, p5, cols = 1)

```
<br>

## 4.2 Spatial predictions

```{r load raster bricks, echo = FALSE}
load('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/2009_prediction_rasters.Rdata') 
```

Models were evaluated for summer (July 2009) and winter(January 2009) across the entire Gulf of Mexico (US EEZ beyond the 200m contour).

```{r Ac Spatial Predict, warning = FALSE, echo = FALSE}
### Acoustic Only spatial prediction

# set out of range values in rasters to NA
jan2009_rastersAc <- jan2009_rasters
july2009_rastersAc <- july2009_rasters

for (thisVarName in names(jan2009_rastersAc)){
  jan2009_rastersAc[[thisVarName]][jan2009_rastersAc[[thisVarName]]<
                              AcOnlyRangesMin[thisVarName]]<- NA
  jan2009_rastersAc[[thisVarName]][jan2009_rastersAc[[thisVarName]]>
                              AcOnlyRangesMax[thisVarName]]<- NA
  
  july2009_rastersAc[[thisVarName]][july2009_rastersAc[[thisVarName]]<
                              AcOnlyRangesMin[thisVarName]]<- NA
  july2009_rastersAc[[thisVarName]][july2009_rastersAc[[thisVarName]]>
                              AcOnlyRangesMax[thisVarName]]<- NA
}

jan2009_AcOnly_prediction <- raster::predict(jan2009_rastersAc,
                                             AcOnly_model,
                                             type = 'response',na.action = na.pass)/10  
jan2009_AcOnly_prediction_IncludingOutsideObs <- raster::predict(jan2009_rasters,
                                             AcOnly_model,
                                             type = 'response',na.action = na.pass)/10  
july2009_AcOnly_prediction <- raster::predict(july2009_rastersAc,
                                              AcOnly_model,
                                              type = 'response',na.action = na.pass)/10
july2009_AcOnly_prediction_IncludingOutsideObs <- raster::predict(july2009_rasters,
                                              AcOnly_model,
                                              type = 'response',na.action = na.pass)/10  
```


```{r Vis Spatial Predict, warning = FALSE, echo = FALSE}
### Visual Only spatial prediction
#dt1 <- as.data.frame(jan2009_rasters,xy=TRUE)

jan2009_rastersVis <- jan2009_rasters
july2009_rastersVis <- july2009_rasters

for (thisVarName in names(jan2009_rastersVis)){
  jan2009_rastersVis[[thisVarName]][jan2009_rastersVis[[thisVarName]]<
                              VisOnlyRangesMin[thisVarName]]<- NA
  jan2009_rastersVis[[thisVarName]][jan2009_rastersVis[[thisVarName]]>
                              VisOnlyRangesMax[thisVarName]]<- NA
  
  july2009_rastersVis[[thisVarName]][july2009_rastersVis[[thisVarName]]<
                              VisOnlyRangesMin[thisVarName]]<- NA
  july2009_rastersVis[[thisVarName]][july2009_rastersVis[[thisVarName]]>
                              VisOnlyRangesMax[thisVarName]]<- NA
}

jan2009_VisOnly_prediction <- raster::predict(jan2009_rastersVis,VisOnly_model,
            type = 'response',na.action = na.pass)/10
jan2009_VisOnly_prediction_IncludingOutsideObs <- raster::predict(jan2009_rasters,VisOnly_model,
            type = 'response',na.action = na.pass)/10

july2009_VisOnly_prediction <- raster::predict(july2009_rastersVis,VisOnly_model,
            type = 'response',na.action = na.pass)/10
july2009_VisOnly_prediction_IncludingOutsideObs <- raster::predict(july2009_rasters,VisOnly_model,
            type = 'response',na.action = na.pass)/10
```



```{r Joint Spatial Predict, message=FALSE, warning = FALSE, echo = FALSE}
### Joint Visual and Acoustic spatial prediction

jan2009_rastersJoint <- jan2009_rasters
july2009_rastersJoint <- july2009_rasters

for (thisVarName in names(jan2009_rastersJoint)){
  jan2009_rastersJoint[[thisVarName]][jan2009_rastersJoint[[thisVarName]]<
                              JointRangesMin[thisVarName]]<- NA
  jan2009_rastersJoint[[thisVarName]][jan2009_rastersJoint[[thisVarName]]>
                              JointRangesMax[thisVarName]]<- NA
  
  july2009_rastersJoint[[thisVarName]][july2009_rastersJoint[[thisVarName]]<
                              JointRangesMin[thisVarName]]<- NA
  july2009_rastersJoint[[thisVarName]][july2009_rastersJoint[[thisVarName]]>
                              JointRangesMax[thisVarName]]<- NA
}


jan2009_prediction <- raster::predict(jan2009_rastersJoint,Joint_model,
            type = 'response',na.action = na.pass,se.fit=TRUE)/10  
            
july2009_prediction <- raster::predict(july2009_rastersJoint,Joint_model,
            type = 'response',na.action = na.pass,se.fit=TRUE)/10      
```


```{r wrangle projections, message = FALSE, warning = FALSE, echo = FALSE, results = 'hide'}
# Wrangle projections for mapping:

predTemplate <-raster('E:/NASData/Eddy/RefRaster.tif')
map_proj <- crs(predTemplate)
crop_limits <- readOGR('E:/NASData/AcoustoVisualDE/Prediction_template/prediction_polygon.shp',verbose=FALSE)
crop_limits_proj <- spTransform(crop_limits, CRSobj = map_proj)

# Acoustic
jan2009_AcOnly_prediction_crop <- mask(jan2009_AcOnly_prediction,crop_limits_proj)
july2009_AcOnly_prediction_crop <-
  mask(july2009_AcOnly_prediction,crop_limits_proj)
jan2009_AcOnly_map_probSee <- jan2009_AcOnly_prediction_crop*visG0*visDetProb
july2009_AcOnly_map_probSee <- july2009_AcOnly_prediction_crop*visG0*visDetProb

# Visual
jan2009_VisOnly_prediction_crop <- 
  mask(jan2009_VisOnly_prediction,crop_limits_proj)
july2009_VisOnly_prediction_crop <- mask(july2009_VisOnly_prediction,crop_limits_proj)
jan2009_VisOnly_map_probSee <- jan2009_VisOnly_prediction_crop*visG0*visDetProb
july2009_VisOnly_map_probSee <- july2009_VisOnly_prediction_crop*visG0*visDetProb

# Joint
jan2009_prediction_crop <- mask(jan2009_prediction,crop_limits_proj)
july2009_prediction_crop <- mask(july2009_prediction,crop_limits_proj)
jan2009_map_probSee <- jan2009_prediction_crop*visG0*visDetProb
july2009_map_probSee <- july2009_prediction_crop*visG0*visDetProb
```

Note: As an alternative to training joint models, an average surface was computed across the acoustic and visual-only predictions.


Each grid cell in the following maps represents a 10x10 km square. Densities are therefore shown as estimated number of animals per 100 km^2^.

<br>

```{r Model Averaging, warning = FALSE, echo = FALSE}
### Model averaging 

# Alternatively, the visual and acoustic models could be averaged.
jan2009mean <- mean(jan2009_AcOnly_prediction_IncludingOutsideObs,
                    jan2009_VisOnly_prediction_IncludingOutsideObs,na.rm = TRUE)
july2009mean <- mean(july2009_AcOnly_prediction_IncludingOutsideObs,
                     july2009_VisOnly_prediction_IncludingOutsideObs,na.rm = TRUE)

jan2009mean_prediction_crop <- mask(jan2009mean,jan2009_prediction_crop)
july2009mean_prediction_crop <- mask(july2009mean,july2009_prediction_crop)

jan2009mean_prediction_probSee <- jan2009mean_prediction_crop*visG0*visDetProb
july2009mean_prediction_probSee <- july2009mean_prediction_crop*visG0*visDetProb
```


**Summer 2009 predicted distribution and test sightings:**


```{r leaflet summer, message = FALSE, warning = FALSE, echo = FALSE}
# Display summer (July 2009) map:
maxColor <- ceiling(max(c(july2009_AcOnly_prediction_crop@data@max,
               july2009_VisOnly_prediction_crop@data@max,
               july2009_prediction_crop@data@max,
               july2009mean_prediction_crop@data@max,
               jan2009_AcOnly_prediction_crop@data@max,
               jan2009_VisOnly_prediction_crop@data@max,
               jan2009_prediction_crop@data@max,
               jan2009mean_prediction_crop@data@max))*10)/10
pal <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColor), 
                    na.color = 'transparent')
GU2009Effort <- readOGR('E:/NASData/GU2009Effort/GU_Effort_Merge_clip_Project.shp',verbose=FALSE)
GU2009EffortLines <- sp::spTransform(GU2009Effort, CRSobj = CRS('+init=epsg:4326'))

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(july2009_AcOnly_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Acoustic July 2009') %>%
  addRasterImage(july2009_VisOnly_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Visual July 2009') %>%
  addRasterImage(july2009_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Joint July 2009') %>%
  addRasterImage(july2009mean_prediction_crop,colors = pal,
                 opacity = 0.8, group = 'Vis. & Ac. Mean July 2009') %>%
  addPolylines(data = GU2009EffortLines,
               group ='Visual Effort (Summer 2009)', 
               opacity = 1,
               color = "black", weight = 2)%>%
  addCircleMarkers(data = sightingsTest, lng = ~ long, lat = ~ lat,
                 color = "black",
                 stroke = TRUE, fillOpacity = 0.8,radius = 6,
                 group = 'Test Sightings (Summer 2009)') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%

  addLegend(pal = pal, values = c(0,maxColor),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic July 2009','Visual July 2009',
                   'Joint July 2009','Vis. & Ac. Mean July 2009'),
    overlayGroups = c('Test Sightings (Summer 2009)',
                      'Visual Effort (Summer 2009)'),
    options = layersControlOptions(collapsed = FALSE)
  )
map

```
<br>

**Winter 2009 predicted distribution:**

```{r leaflet winter, message = FALSE, warning = FALSE, echo = FALSE}
# Display winter (January 2009) map:

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(jan2009_AcOnly_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Acoustic Jan. 2009') %>%
  addRasterImage(jan2009_VisOnly_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Visual Jan. 2009') %>%
  addRasterImage(jan2009_prediction_crop, colors = pal,
                 opacity = 0.8, group = 'Joint Jan. 2009') %>%
  addRasterImage(jan2009mean_prediction_crop,colors = pal,
                 opacity = 0.8, group = 'Vis. & Ac. Mean Jan. 2009') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%
  addLegend(pal = pal, values = c(0,maxColor),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic Jan. 2009','Visual Jan. 2009',
                   'Joint Jan. 2009','Vis. & Ac. Mean Jan. 2009'),
    options = layersControlOptions(collapsed = FALSE)
  )
map

```

<br>

# 5. Monthly model predictions

Spatial model predictions were generated using climatological means of oceanographic variables, averaged by month between 2003 and 2015.


```{r evaluate climatology-based models, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
# to recalculate the climatology raster stack:
# source('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/scaled_climate_raster_stack.R', echo=TRUE)
# scaled_climate_raster_stack(covars_Joint_max.train,covars_Joint_min.train) 

load('E:/NASData/AcoustoVisualDE/AcoustoVisualDE/climatology_rasters_UNscaled.Rdata') 
monthNum <-c('01','02','03','04','05','06','07','08','09','10','11','12')
monthStr<-c('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec')

climatePrediction <- vector('list',length = 12)
mapClimatePrediction <- vector('list',length = 12)

for (iM in 1:length(monthStr)){
  climatePrediction[[iM]] <- raster::predict(raster_set[[iM]],Joint_model,
            type = 'response',na.action = na.pass)/10
  mapClimatePrediction[[iM]] <- mask(climatePrediction[[iM]], crop_limits_proj)  
  # output raster to geotiff
  rasterImageFileName = paste0(savePath,'/climatology_predictions/', SP,'_',monthStr[iM],'GAM_mean_density.tif')
  writeRaster(mapClimatePrediction[[iM]],filename = rasterImageFileName, format="GTiff",overwrite = TRUE)
  
  # #ouput raster to kml
  # kmlImageFileName = paste0(savePath,'/climatology_predictions/', SP,'_',monthStr[iM],'NN_mean_encounter_probability.kml')
  # KML(mapClimatePrediction[[iM]],file = kmlImageFileName, col=matlab.like2(32),overwrite = TRUE)
}
  
```

```{r plot climatologies, eval = TRUE, message = FALSE, warning = FALSE, echo = FALSE}
maxColor <- ceiling(max(c(mapClimatePrediction[[1]]@data@max,
                mapClimatePrediction[[3]]@data@max,
                mapClimatePrediction[[5]]@data@max,
                mapClimatePrediction[[7]]@data@max,
                mapClimatePrediction[[9]]@data@max,
                mapClimatePrediction[[11]]@data@max))*10)/10

pal <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColor), 
                    na.color = 'transparent')

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(mapClimatePrediction[[1]] , colors = pal,
                 opacity = 0.8, group = 'Jan.') %>%
  addRasterImage(mapClimatePrediction[[3]] , colors = pal,
                 opacity = 0.8, group = 'March') %>%
  addRasterImage(mapClimatePrediction[[5]] , colors = pal,
                 opacity = 0.8, group = 'May') %>%
  addRasterImage(mapClimatePrediction[[7]] , colors = pal,
                 opacity = 0.8, group = 'July') %>%
  addRasterImage(mapClimatePrediction[[9]] ,colors = pal,
                 opacity = 0.8, group = 'Sept.') %>%
  addRasterImage(mapClimatePrediction[[11]] ,colors = pal,
                 opacity = 0.8, group = 'Nov.') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat,
             group = "HARP Locations") %>%
  addLegend(pal = pal, values = c(0,maxColor),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Jan.','March','May',
                   'July','Sept.','Nov.'),
    overlayGroups = c('HARP Locations'),
    options = layersControlOptions(collapsed = FALSE)
  )
map
```


# References
