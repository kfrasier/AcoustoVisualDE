---
title: "GoMx _Stenella_ spp. habitat models: Density with neural nets"
author: 
- name: Kaitlin Frasier
  affiliation: Scripps Institution of Oceanography, UC San Diego
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    theme: spacelab
    fig_caption: true 
bibliography: exportlist.bibtex
csl: plos-computational-biology.csl
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load packages, echo = FALSE, message = FALSE, warning = FALSE}
library(rgdal)
library(raster)
library(ggplot2)
library(rgeos)
library(mapview)
library(leaflet)
library(psych)
library(broom)
library(plotrix)
library(magrittr)
library(colorRamps)
library(lubridate)
#library(HabitatProject)
library(nnet)
library(caret)
library(parallel)
library(MLmetrics)
library(pracma)
library(grid)
library(knitr)
library(matrixStats)
library(zoo)
library(tmap)
library(scales)
source('F:/GRIIDC_inputs/HabitatProject/R/plot_covarDensity.R')
source('F:/GRIIDC_inputs/HabitatProject/R/weighted_logloss.R')
source('F:/GRIIDC_inputs/HabitatProject/R/multiplot.R')
source('F:/GRIIDC_inputs/HabitatProject/R/plot_missingdata.R')
source('F:/GRIIDC_inputs/HabitatProject/R/plot_cleveland.R')
source('F:/GRIIDC_inputs/HabitatProject/R/plot_timeseries.R')
source('F:/GRIIDC_inputs/HabitatProject/R/transform_covars.R')
source('F:/GRIIDC_inputs/nnet_plot_update.r')
options(stringsAsFactors = FALSE)
# load some preferences
load('F:/GRIIDC_inputs/ModelData/Ssp/setup_info_Ssp.Rdata')
load('F:/GRIIDC_inputs/ModelData/Ssp/SspMergedData.Rdata')
outDir <- file.path('F:/GRIIDC_inputs/ModelData',SP,'10000//')
inDir <- file.path('F:/GRIIDC_inputs/ModelData',SP,'//')

```
<br>

# 1. Exploratory analysis

<br>

## 1.1 Data Inputs

NOAA SEFSC visual data goes back to 1992, but as shown in the figure below, many predictor variables are only available starting in 2003, therefore earlier visual data is currently excluded from further analyses. 

Note: Future work could use monthly climatologies (averages) so that older sightings data could be used. Some dynamic drivers like eddy and front locations would not be able to be considered using that approach.

```{r Missing data, results = 'hide', echo = FALSE, message= FALSE, warning = FALSE}
plotCols1 <-c(7:10,14,16,19,22,23)
covarList<-names(mergedSegments[c(plotCols1)])
varUnits <- c("SST (C)","SSH (m)",expression("Chlorophyll A (mg/m"^3*")"),"MLD (m)", "Salinity (ppm)",
                 "Current Magnitude (m/sec)", "Upwelling (m/sec)", 
                 "Dist. to Anti-Cyclonic Eddy (km)","Dist. to Cyclonic Eddy (km)")

names(varUnits)<-covarList

plot.missingdata(AcOnlySegments,covarList,
                               paste0(outDir,'AcousticOnly_',SP),varUnits) 
plot.missingdata(VisOnlySegments,covarList,
                               paste0(outDir,'VisualOnly_',SP),varUnits) 
visDataAvailPlot <- paste0(outDir,'/VisualOnly_',SP,'_missingData.png')
```

**Visual data predictor variable availability:** 

![](`r visDataAvailPlot`)

<br> 


### 1.1.1 Splitting into testing and training sets

The data are split into training and testing sets. In this case, visual data from 2009 and acoustic data from 2013 were used only for testing. Only observations from 2003 or later were used for modeling due to covariate limitations.  

```{r test train split, echo = FALSE}
# If you decide from the missing data plots that you want to restrict years going forward:
yearListIdx_AcOnly = as.numeric(format(AcOnlySegments$date,"%Y"))
yearListIdx_VisOnly = as.numeric(format(VisOnlySegments$date,"%Y"))
isVisual <- mergedSegments$Category

keepDates_AcOnly.train <- which(yearListIdx_AcOnly != 2009 & 
                  yearListIdx_AcOnly >= 2003 & yearListIdx_AcOnly <= 2012)

keepDates_AcOnly.test <- which(yearListIdx_AcOnly == 2009 |
                                 yearListIdx_AcOnly == 2013)
keepDatesVisOnly.train <- which(yearListIdx_VisOnly != 2009 & 
                                  yearListIdx_VisOnly >= 2003)
keepDatesVisOnly.test <- which(yearListIdx_VisOnly == 2009 |
                                 yearListIdx_VisOnly == 2013)

Train_AcOnly.set <- AcOnlySegments[keepDates_AcOnly.train,]
Train_VisOnly.set<- VisOnlySegments[keepDatesVisOnly.train,]

Test_AcOnly.set<- AcOnlySegments[keepDates_AcOnly.test,]
Test_VisOnly.set<- VisOnlySegments[keepDatesVisOnly.test,]
```


<br>

### 1.1.2 Map of visual sightings data

The visual data selected for modeling are displayed on the map below. Data from 2009 were held back for testing. Blue markers indicate HARP locations.

```{r map inputs, warning = FALSE, echo = FALSE}
# Get test visual sightings
sightingsTrain <- Train_VisOnly.set[Train_VisOnly.set$Density>0,c('lat','long','date')]

sightingsTest <- Test_VisOnly.set[Test_VisOnly.set$Density>0,c('lat','long','date')]
HARPsites <- unique(Train_AcOnly.set[c('lat','long')])
pal <-colorFactor(palette = "RdYlGn", 
                  domain = c(2003,2004,2009,2012,2014))
  
map1 <- leaflet() %>%  setView(lng = -89.4, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addCircleMarkers(data = sightingsTrain, lng = ~ long, lat = ~ lat,color = ~pal(year(date)),
                 stroke = TRUE, fillOpacity = 0.8, group = 'Training Set',radius = 4)%>%
  addCircleMarkers(data = sightingsTest, lng = ~ long, lat = ~ lat,color = ~pal(year(date)),
                 stroke = TRUE, fillOpacity = 0.8, group = 'Test Set',radius = 4)%>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%
  addLegend(pal = pal,values = c(2003,2004,2009,2012,2014),title = 'Year') 

map1
```
<br>

### 1.1.3 Time series of acoustic data

The time series below show timeseries of estimated densities from passive acoustic data used for modeling (Densities were calculated following methods detailed in @RN806). Data from 2011 and 2012 were used for training, and 2013 data was held back for testing. 

<br> 

**Acoustic Timeseries:**
```{r plot timeseries, message = FALSE, echo = FALSE}
plot.timeseries(siteList,outDir,AcOnlySegments)
MCTS <- paste0(outDir,SP,'_Timeseries_Site_MC.png')
GCTS <- paste0(outDir,SP,'_Timeseries_Site_GC.png')
DTTS <- paste0(outDir,SP,'_Timeseries_Site_DT.png')
DCTS <- paste0(outDir,SP,'_Timeseries_Site_DC.png')
MPTS <- paste0(outDir,SP,'_Timeseries_Site_MP.png')
```


![](`r MCTS`)
![](`r GCTS`)
![](`r DTTS`)
![](`r DCTS`)
![](`r MPTS`)
<br> 

## 1.2 Examination of covariates

```{r remove outliers, message = FALSE, results = 'hide', echo = FALSE}
### Identify Outliers
# Replace extreme outliers (bad data) with NaNs.
outlierList <-which(Train_AcOnly.set$CHL< -10)
Train_AcOnly.set$CHL[outlierList] <- NaN 
outlierList <-which(Train_AcOnly.set$Density > 100000)
Train_AcOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Test_AcOnly.set$CHL< -10)
Test_AcOnly.set$CHL[outlierList] <- NaN 
outlierList <-which(Test_AcOnly.set$Density>100000)
Test_AcOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Train_VisOnly.set$CHL< -10)
Train_VisOnly.set$CHL[outlierList] <- NaN 
outlierList <-which(Train_VisOnly.set$Density>100000)
Train_VisOnly.set$Density[outlierList] <- NaN 

outlierList <-which(Test_VisOnly.set$CHL<  -10)
Test_VisOnly.set$CHL[outlierList] <- NaN 
outlierList <-which(Test_VisOnly.set$Density>100000)
Test_VisOnly.set$Density[outlierList] <- NaN 
```

<br>

### 1.2.1 Covariate distribution check
 
<br> 

**Distributions of covariates from acoustic observations (training data only):**

```{r dot plots, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}

plot.cleveland(Train_AcOnly.set,covarList,FALSE,paste0(outDir,'AcousticOnly_',SP),varUnits)
plot.cleveland(Train_VisOnly.set,covarList,FALSE,paste0(outDir,'VisualOnly_',SP),varUnits)
ACclevelandPlot<-paste0(outDir,'AcousticOnly_',
                        SP,'_clevelandDots_noTransform.png')
VisclevelandPlot<-paste0(outDir,'VisualOnly_',
                        SP,'_clevelandDots_noTransform.png')
```

![](`r ACclevelandPlot`)


<br>

**Distributions of covariates from the visual observations (training data only):**

![](`r VisclevelandPlot`)

<br>

Some of these covariates are more or less interrelated. Correlations are examined in the figure below. Numbers closer to 1 above the diagonal in the figure below represent correlation coefficients. If a pair of covariates is highly-correlated only one should typically be used in the model.

```{r correlation plots, eval = TRUE, message = FALSE, warning = FALSE, results = 'hide', echo = FALSE}
covarList2 <- c("Density","SST","SSH","CHL",
                "HYCOM_MLD","HYCOM_SALIN_0","HYCOM_MAG_0",
                "HYCOM_UPVEL_50",
                "Neg_EddyDist","Pos_EddyDist",
                "fac1","fac2","EffectiveArea")

# restrict covariates again to limited set
Train_AcOnly.set2<- Train_AcOnly.set[,covarList2]
Test_AcOnly.set2<- Test_AcOnly.set[,covarList2]
Train_VisOnly.set2<- Train_VisOnly.set[,covarList2]
Test_VisOnly.set2<- Test_VisOnly.set[,covarList2]

# without transform
png(paste(outDir,SP,'_correlations_noTransform_AcOnly.png',sep=''), width = 2000, height = 1600)
pairs.panels(Train_AcOnly.set2[,1:(length(covarList2)-3)], ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off()
png(paste(outDir,SP,'_correlations_noTransform_visOnly.png',sep=''), width = 2000, height = 1600)
pairs.panels(Train_VisOnly.set2[,1:(length(covarList2)-3)], ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off()
covarPlot <-paste0(outDir,SP,'_correlations_noTransform_AcOnly.png')
```
<br> 

**Covariate Correlations:**

![](`r covarPlot`)

<br>

### 1.2.2 Transformation of predictor variables

Some variables, including chlorophyll, mixed layer depth and distance to fronts are highly skewed and were log-transformed for input to GAMs.

```{r transform covars, message = FALSE, results = 'hide', echo = FALSE, warning = FALSE}
# covarList2 <- c("Density","SST","SSH","CHL",
#                 "HYCOM_MLD","HYCOM_SALIN_0","HYCOM_MAG_0",
#                 "HYCOM_UPVEL_50",
#                 "Neg_EddyDist", "PosEddyDist",
#                 "fac1","fac2")

transformList <- c("none","none","none","log10",
                   "log10","none","log10",
                   "none",
                   "none","none",
                   "none","none","none")

transformedCovars_AcOnly.train <-
  transform.covars(Train_AcOnly.set2,covarList2,transformList)
transformedCovars_AcOnly.test <-
  transform.covars(Test_AcOnly.set2,covarList2,transformList)
transformedCovars_VisOnly.train <-
  transform.covars(Train_VisOnly.set2,covarList2,transformList)
transformedCovars_VisOnly.test <-
  transform.covars(Test_VisOnly.set2,covarList2,transformList)

# Generate correlation plots with transform

png(paste(outDir,SP,'_correlations_withTransform_AcOnly.png',sep=''), 
    width = 2000, height = 1600)
pairs.panels(transformedCovars_AcOnly.train[,1:(length(covarList2)-2)], 
             ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off() 

png(paste(outDir,SP,'_correlations_withTransform_visOnly.png',sep=''), 
    width = 2000, height = 1600)
pairs.panels(transformedCovars_VisOnly.train[,1:(length(covarList2)-2)],
             ellipses=FALSE, method = "spearman",cex.cor=.75)
dev.off() 

```


```{r transformed dot plots, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}
# Plotting the transformed variables: 

plotCols = colnames(transformedCovars_AcOnly.train)[c(2:10)]
names(varUnits)<-plotCols
varUnits["log10_HYCOM_MAG_0"]<-expression("log"[10]*"(Current Magnitude (m/sec))")

varUnits["log10_HYCOM_MLD"]<- expression("log"[10]*"(MLD (m))")
varUnits["log10_CHL"] <-expression("log"[10]*"(Chorophyll A (mg/m"^3*"))")

plot.cleveland(transformedCovars_AcOnly.train,
               plotCols,TRUE,paste0(outDir,'AcousticOnly_',SP),varUnits)
plot.cleveland(transformedCovars_VisOnly.train,
               plotCols,TRUE,paste0(outDir,'VisualOnly_',SP),varUnits)
```


<br>

### 1.2.3 Preliminary check of predictive power 

To get an idea of the basic predictive power of these covariates, we can look at presence/absence relative to each variable. This also provides an opportunity to look at the range of values observed for each covariate in the visual and acoustic datasets. In the plots below dotted lines indicate the distribution of each covariate when `r SPLong` were present, and solid lines indicate the distribution when `r SPLong` were absent. Note that these plots do not account for effort.

```{r presence absence histograms, eval = TRUE, message = FALSE, results = 'hide', echo = FALSE}
plot.covarDensity(transformedCovars_AcOnly.train[,2:10],
                   colnames(transformedCovars_AcOnly.train[2:10]),
                  transformedCovars_AcOnly.train$Density,paste0(outDir,'AcousticOnly_',SP),varUnits)		

plot.covarDensity(transformedCovars_VisOnly.train[,2:10],
                  colnames(transformedCovars_VisOnly.train[,2:10]),
                  transformedCovars_VisOnly.train$Density,paste0(outDir,'VisualOnly_',SP),varUnits)
acKernels <-paste0(outDir,'/AcousticOnly_',SP,'_density_pres_abs.png')
visKernels <- paste0(outDir,'/VisualOnly_',SP,'_density_pres_abs.png')
```

<br> 

**Acoustic kernel densities:**

![](`r acKernels`)

<br>  
**Visual kernel densities:**

![](`r visKernels`)

<br>  

```{r load detection prob, echo = FALSE} 
visDetProbData<-paste0(inDir,SP,'sightwTrunc_GU.Rdata')
load(visDetProbData)
visDetProb <- detFun[[bestModelIdx]]$fitted[1]
visDetProbFigure <- paste0(inDir,SP,'sightwTrunc_GU.png')
```


**Best visual detection probability model for `r SPLong`:**

![](`r visDetProbFigure`)

<br>

# 2. Model Fitting

Models were fit using avnnet from the caret package in R. 


```{r model setup, echo = FALSE, message = FALSE, results = 'hide'} 
yAcOnly <- transformedCovars_AcOnly.train$Density
yVisOnly <- transformedCovars_VisOnly.train$Density

visDetProb <- detFun[[bestModelIdx]]$fitted[1]

transformedCovars_AcOnly.train$yAcOnly<- transformedCovars_AcOnly.train$Density
transformedCovars_VisOnly.train$yVisOnly<-transformedCovars_VisOnly.train$Density
transformedCovars_AcOnly.train$yAcOnlySqrt <-sqrt(transformedCovars_AcOnly.train$Density)
transformedCovars_VisOnly.train$yVisOnlySqrt <-sqrt(transformedCovars_VisOnly.train$Density)

transformedCovars_AcOnly.test$yAcOnly <- transformedCovars_AcOnly.test$Density
transformedCovars_VisOnly.test$yVisOnly <- transformedCovars_VisOnly.test$Density
transformedCovars_AcOnly.test$yAcOnlySqrt <-sqrt(transformedCovars_AcOnly.test$Density)
transformedCovars_VisOnly.test$yVisOnlySqrt <-sqrt(transformedCovars_VisOnly.test$Density)


# Remove NaNs
goodData_Ac <- which(!is.na(rowSums(transformedCovars_AcOnly.train)))
AcOnly.train.NoNa <- transformedCovars_AcOnly.train[goodData_Ac,]

goodData_Vis <- which(!is.na(rowSums(transformedCovars_VisOnly.train)))
VisOnly.train.NoNa <- transformedCovars_VisOnly.train[goodData_Vis,]


goodData_Ac_test <- which(!is.na(rowSums(transformedCovars_AcOnly.test)))
AcOnly.test.NoNa <- transformedCovars_AcOnly.test[goodData_Ac_test,]

goodData_Vis_test <- which(!is.na(rowSums(transformedCovars_VisOnly.test)))
VisOnly.test.NoNa <- transformedCovars_VisOnly.test[goodData_Vis_test,]

```

<br>


```{r Scale all the data, echo = FALSE}
# NNs don't do well with unscaled data. Scale it and then unscale it at the end.
# Scale training data for the NN
covars_AcOnly_max.train <- apply(AcOnly.train.NoNa, 2, max, na.rm = TRUE) 
covars_AcOnly_min.train <- apply(AcOnly.train.NoNa, 2, min, na.rm = TRUE)
covars_AcOnly_mean.train <- apply(AcOnly.train.NoNa, 2, mean, na.rm = TRUE) 
covars_AcOnly_std.train <- apply(AcOnly.train.NoNa, 2, std) 

covars_VisOnly_max.train <- apply(VisOnly.train.NoNa, 2, max, na.rm = TRUE) 
covars_VisOnly_min.train <- apply(VisOnly.train.NoNa, 2, min, na.rm = TRUE)
covars_VisOnly_mean.train <- apply(VisOnly.train.NoNa, 2, mean, na.rm = TRUE) 
covars_VisOnly_std.train <- apply(VisOnly.train.NoNa, 2, std) 

# Scale Ac only training data for the NN
AcOnly_train_scaled <- as.data.frame(scale(AcOnly.train.NoNa, 
                          center = covars_AcOnly_min.train, 
                        scale = covars_AcOnly_max.train-covars_AcOnly_min.train))
AcOnly_train_scaled$yAcOnly <-log(AcOnly.train.NoNa$yAcOnly+1)/log(covars_AcOnly_max.train['yAcOnly'])
AcOnly_train_scaled$yAcOnly [is.infinite(AcOnly_train_scaled$yAcOnly )]<-0
AcOnly_train_scaled$yAcOnlySqrt <- AcOnly.train.NoNa$yAcOnlySqrt

# Scale Vis only training data for the NN
VisOnly_train_scaled <- as.data.frame(scale(VisOnly.train.NoNa, 
                          center = covars_VisOnly_min.train, 
                        scale = covars_VisOnly_max.train-covars_VisOnly_min.train))
VisOnly_train_scaled$yVisOnly <- log(VisOnly.train.NoNa$yVisOnly+1)/log(covars_VisOnly_max.train['yVisOnly'])
VisOnly_train_scaled$yVisOnly[is.infinite(VisOnly_train_scaled$yVisOnly)]<-0
VisOnly_train_scaled$yVisOnlySqrt <- VisOnly.train.NoNa$yVisOnlySqrt


# Scale Ac only test data for the NN
AcOnly_test_scaled <- as.data.frame(scale(AcOnly.test.NoNa, 
                        center = covars_AcOnly_min.train, 
                        scale = covars_AcOnly_max.train-covars_AcOnly_min.train))
AcOnly_test_scaled$yAcOnly <- log(AcOnly.test.NoNa$yAcOnly+1)/log(covars_AcOnly_max.train['yAcOnly'])
AcOnly_test_scaled$yAcOnly[is.infinite(AcOnly_test_scaled$yAcOnly)]<-0
AcOnly_test_scaled$yAcOnlySqrt <- AcOnly.test.NoNa$yAcOnlySqrt

# Scale Vis only test data for the NN
VisOnly_test_scaled <- as.data.frame(scale(VisOnly.test.NoNa, 
                        center = covars_VisOnly_min.train, 
                        scale = covars_VisOnly_max.train-covars_VisOnly_min.train))
VisOnly_test_scaled$yVisOnly <- log(VisOnly.test.NoNa$yVisOnly+1)/log(covars_VisOnly_max.train['yVisOnly'])
VisOnly_test_scaled$yVisOnly[is.infinite(VisOnly_test_scaled$yVisOnly )]<-0
VisOnly_test_scaled$yVisOnlySqrt <- VisOnly.test.NoNa$yVisOnlySqrt


n <- names(AcOnly_test_scaled)


# save ranges of each scaled covariate in training set (max and min)
AcOnlyRangesMax <- apply(AcOnly_train_scaled, MARGIN = 2,
                         function(x) max(x, na.rm =TRUE))
AcOnlyRangesMin <- apply(AcOnly_train_scaled, MARGIN = 2,
                         function(x) min(x, na.rm =TRUE))

VisOnlyRangesMax <- apply(VisOnly_train_scaled, MARGIN = 2,
                          function(x) max(x, na.rm =TRUE))
VisOnlyRangesMin <- apply(VisOnly_train_scaled, MARGIN = 2,
                          function(x) min(x, na.rm=TRUE))
```

<br> 

## 2.1 Run Models 

```{r, echo = FALSE}
# set up model params
model1.indices <- c(2:10)
nMax1 <- length(model1.indices)
layerSizeList <- c(4,6,8,10,12,14)
trainRepeats <- 25

```

Run NNs on Acoustic and Visual datasets.

Models have the following characteristics: 

* `R trainRepeats` averaged repeats with random node initalization

* Include `r length(model1.indices)` covariates 

* One hidden layer 

* Weighted training data 

* Hidden node layer sizes from `r min(layerSizeList)` to `r max(layerSizeList)` were tested in 2 node increments to search for optimal network size. 
 
<br>


```{r, echo = FALSE}

# initialize empty structure for model storage
nn_AcOnly<-NULL
nn_VisOnly<-NULL

# initialize empty structure for error scores and predictions
MSE <- NULL
pr <- NULL

```


```{r Ac only Model, results = 'hide', message = FALSE, eval = FALSE, echo = FALSE}
## ACOUSTIC ONLY
AcCounter <- 0
f.AcOnly_NN1 <- as.formula(paste("yAcOnly ~", paste(n[model1.indices], collapse = " + ")))
# Iterate over a range of hidden layer sizes between 2 and 14 nodes.

for (layerSize in layerSizeList){
  AcCounter <- AcCounter + 1  
  # put together the formula
  # train network
  nn_AcOnly[[AcCounter]] <- avNNet(f.AcOnly_NN1, data = AcOnly_train_scaled, 
                                 size = layerSize, 
                                 repeats = trainRepeats,
                                 na.action = na.omit,
                                 rang = 0.7, 
                                 decay = 0.0001, 
                                 maxit = 10000,
                                 trace = FALSE)
  
  # predict on train data and estimate Mean Squared Error (MSE)
  pr$nn_AcOnly_train[[AcCounter]] <- predict(nn_AcOnly[[AcCounter]],
                                      AcOnly_train_scaled[,model1.indices])
  pr$nn_AcOnly_train[[AcCounter]][pr$nn_AcOnly_train[[AcCounter]] <0]<-0
  MSE$nn_AcOnly_train[[AcCounter]] <- mean(abs(AcOnly_train_scaled$yAcOnly - 
                                    pr$nn_AcOnly_train[[AcCounter]]),na.rm = TRUE)
  
  # predict on test data and estimate MSE
  pr$nn_AcOnly_test[[AcCounter]] <- predict(nn_AcOnly[[AcCounter]],
                                     AcOnly_test_scaled[,model1.indices])
  pr$nn_AcOnly_test[[AcCounter]][pr$nn_AcOnly_test[[AcCounter]] <0]<-0
  MSE$nn_AcOnly_test[[AcCounter]] <- mean(abs(exp(log(covars_AcOnly_max.train['yAcOnly'])* 
                                                (AcOnly_test_scaled$yAcOnly - 
                                    pr$nn_AcOnly_test[[AcCounter]]))),na.rm = TRUE)
  

}
```



```{r Vis only model, eval = FALSE, echo = FALSE} 
## VISUAL ONLY
modelCounter <- 0
# put together the formula
f.VisOnly_NN1 <- as.formula(paste("yVisOnly ~", paste(n[model1.indices], collapse = " + ")))
for (layerSize in layerSizeList){
  modelCounter <- modelCounter + 1  
  # train network
  nn_VisOnly[[modelCounter]] <- avNNet(f.VisOnly_NN1, VisOnly_train_scaled,
                                       size = layerSize, 
                                       repeats = trainRepeats,
                                       na.action = na.omit,
                                       rang = 0.7,  
                                       decay = 0.0001, 
                                       maxit = 10000,
                                       trace = FALSE)
  
  # predict on train data and estimate MSE
  pr$nn_VisOnly_train[[modelCounter]] <- predict(nn_VisOnly[[modelCounter]],
                                                VisOnly_train_scaled[,model1.indices])
  pr$nn_VisOnly_train[[modelCounter]][ pr$nn_VisOnly_train[[modelCounter]]<0]<-0
  MSE$nn_VisOnly_train[[modelCounter]] <- mean(
                                        abs(exp(log(covars_VisOnly_max.train['yVisOnly'])*
                                              (VisOnly_train_scaled$yVisOnly - 
                                        pr$nn_VisOnly_train[[modelCounter]]))),na.rm = TRUE)
  
  # predict on test data and estimate MSE
  pr$nn_VisOnly_test[[modelCounter]] <- predict(nn_VisOnly[[modelCounter]],
                                                VisOnly_test_scaled[,model1.indices])
  pr$nn_VisOnly_test[[modelCounter]][ pr$nn_VisOnly_test[[modelCounter]]<0]<-0

  MSE$nn_VisOnly_test[[modelCounter]] <- mean(
                                        abs(exp(log(covars_VisOnly_max.train['yVisOnly'])*
                                              (VisOnly_test_scaled$yVisOnly - 
                                        pr$nn_VisOnly_test[[modelCounter]]))),na.rm = TRUE)
  
 
  cat(paste("Done with VisOnly model iteration ",
            modelCounter, " of ", length(layerSizeList),
            ": Layer Size = ", layerSize, "\n"))
}
```

<br>  


```{r save models, eval = FALSE, echo = FALSE}
# Save models if re-calculating everything
save(nn_AcOnly,MSE,pr,
     file = paste(outDir,SP,'_AcOnly_NN_density_noWeights.Rdata',sep=''))
save(nn_VisOnly,MSE,pr,
     file = paste(outDir,SP,'_VisOnly_NN_density_noWeights.Rdata',sep=''))
```

```{r load models, eval = TRUE, echo = FALSE}
# alternative if models are already calculated
load(paste0(outDir,SP,'_AcOnly_NN_density_noWeights.Rdata'))
load(paste0(outDir,SP,'_VisOnly_NN_density_noWeights.Rdata'))
```

<br>

## 2.2 Model Comparisons

Models were compared using mean absolute error (MAE) to compare predicted and observed density in the test data.


```{r model plots,echo = FALSE}

windowsFonts(A = windowsFont("Times New Roman"))

RMSE <- NULL
MAE <- NULL
wRMSE <- NULL
wMAE <- NULL
modelCounter <-1
for (modelCounter in 1:length(nn_AcOnly)){
#Visual on Visual
  pr$nn_VisOnly_test_VisData[[modelCounter]] <-(exp(log(covars_VisOnly_max.train['yVisOnly'])*
                                                     predict(nn_VisOnly[[modelCounter]],
                                                      VisOnly_test_scaled[,model1.indices],
                                                      na.action = na.omit)))-1
pr$nn_VisOnly_test_VisData[[modelCounter]][pr$nn_VisOnly_test_VisData[[modelCounter]]<0]<-0
RMSE$nn_VisOnly_test_VisData[[modelCounter]] <- sqrt(mean(
                             (VisOnly.test.NoNa$yVisOnly -
                             pr$nn_VisOnly_test_VisData[[modelCounter]])^2,na.rm = TRUE))

# Visual on Acoustic
pr$nn_VisOnly_test_AcData[[modelCounter]] <-(exp(log(covars_VisOnly_max.train['yVisOnly'])*
                                                     predict(nn_VisOnly[[modelCounter]],
                                                      AcOnly_test_scaled[,model1.indices],
                                                      na.action = na.omit)))-1
pr$nn_VisOnly_test_AcData[[modelCounter]][pr$nn_VisOnly_test_AcData[[modelCounter]]<0]<-0

RMSE$nn_VisOnly_test_AcData[[modelCounter]] <- sqrt(mean(
                             (AcOnly.test.NoNa$yAcOnly -
                             pr$nn_VisOnly_test_AcData[[modelCounter]])^2,na.rm = TRUE))

#Acoustic on Visual
pr$nn_AcOnly_test_VisData[[modelCounter]] <-(exp(log(covars_AcOnly_max.train['yAcOnly'])*
                                                     predict(nn_AcOnly[[modelCounter]],
                                                      VisOnly_test_scaled[,model1.indices],
                                                      na.action = na.omit)))-1
pr$nn_AcOnly_test_VisData[[modelCounter]][pr$nn_AcOnly_test_VisData[[modelCounter]]<0]<-0
RMSE$nn_AcOnly_test_VisData[[modelCounter]] <- sqrt(mean(
                             (VisOnly.test.NoNa$yVisOnly -
                             pr$nn_AcOnly_test_VisData[[modelCounter]])^2,na.rm = TRUE))

# Acoustic on Acoustic
pr$nn_AcOnly_test_AcData[[modelCounter]] <-(exp(log(covars_AcOnly_max.train['yAcOnly'])*
                                                     predict(nn_AcOnly[[modelCounter]],
                                                      AcOnly_test_scaled[,model1.indices],
                                                      na.action = na.omit)))-1
pr$nn_AcOnly_test_AcData[[modelCounter]][pr$nn_AcOnly_test_AcData[[modelCounter]]<0]<-0

RMSE$nn_AcOnly_test_AcData[[modelCounter]] <- sqrt(mean(
                             (AcOnly.test.NoNa$yAcOnly -
                             pr$nn_AcOnly_test_AcData[[modelCounter]])^2,na.rm = TRUE))

}

RMSEtable <- rbind(RMSE$nn_AcOnly_test_AcData,RMSE$nn_AcOnly_test_VisData,RMSE$nn_VisOnly_test_VisData,RMSE$nn_VisOnly_test_AcData)
colnames(RMSEtable)<- layerSizeList
rownames(RMSEtable)<- c("Acoustic - Acoustic test data","Acoustic - Visual test data","Visual - Visual test data","Visual - Acoustic test data")

print('RMSE (lower is better)')
print(RMSEtable, digits = 3)

```


```{r best model index, echo = FALSE}
best_AcOnly_ModelIndex <-which.min(RMSE$nn_AcOnly_test_AcData)
print(paste(c('Best acoustic model has', layerSizeList[best_AcOnly_ModelIndex], 
              'nodes.'),collapse = " "))
best_VisOnly_ModelIndex <-which.min(RMSE$nn_VisOnly_test_VisData)
print(paste(c('Best visual model has', layerSizeList[best_VisOnly_ModelIndex],
            'nodes.'),collapse = " "))
```

<br> 

## 2.3 Variable Importance

For the best model in each category, the importance of each input variable was calculated across the 50 model iterations.

```{r, Variable Importance, echo = FALSE, eval = TRUE}
Ac_importance_avg <-varImp(nn_AcOnly[[best_AcOnly_ModelIndex]])
Vis_importance_avg <-varImp(nn_VisOnly[[best_VisOnly_ModelIndex]])

AcOnly_node_mean<-NULL
AcOnly_node_cv<-NULL
VisOnly_node_mean<-NULL
VisOnly_node_cv<-NULL

for (iNode in 1:length(model1.indices)) {
  thisSet <- (1:trainRepeats)+(trainRepeats*(iNode-1))
  
  AcOnly_node_mean[iNode] <- mean(Ac_importance_avg$Overall[thisSet])
  AcOnly_node_cv[iNode] <- std(Ac_importance_avg$Overall[thisSet])/mean(Ac_importance_avg$Overall[thisSet])

  VisOnly_node_mean[iNode] <- mean(Vis_importance_avg$Overall[thisSet])
  VisOnly_node_cv[iNode] <- std(Vis_importance_avg$Overall[thisSet])/mean(Vis_importance_avg$Overall[thisSet])
  
}
mean_var_importance<-NULL
mean_var_importance$AcOnly <- AcOnly_node_mean
mean_var_importance$VisOnly <- VisOnly_node_mean
mean_var_importance<-as.data.frame(mean_var_importance)
row.names(mean_var_importance)<-n[model1.indices]

cv_var_importance<-NULL
cv_var_importance$AcOnly <- AcOnly_node_cv
cv_var_importance$VisOnly <- VisOnly_node_cv
cv_var_importance<-as.data.frame(cv_var_importance)
row.names(cv_var_importance)<-n[model1.indices]

kable(mean_var_importance,'markdown',digits = 1)
```
<br>

```{r plot acoustic network, eval = TRUE, message = FALSE, warning = FALSE, results = 'hide', echo = FALSE, fig.width = 14, fig.height = 8}

n2 = varUnits[n[model1.indices]]
n3 = c("SST","SSH","CHL","MLD","SAL","CUR","Upwell","-Eddy","+Eddy")
png(paste(outDir,SP,'_AcNetwork.png',sep=''), res = 300,width = 5, height = 4, units = "in")
par(mar=c(1,1,1,1),family = 'serif')
NNFitVals <- NULL
for (iN in c(1:trainRepeats)){
  NNFitVals[iN] <- nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iN]]$value
}
bestNetwork <- which.min(NNFitVals)
plot.nnet(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[bestNetwork]],x.lab = n3, y.lab = bquote(hat("D")),bias = F,cex=1.3,circle.col='gray',bord.col = 'darkgray', 
          neg.col = 'red',node.labs = FALSE,circle.cex = 3, alpha.val =.8, max.sp = TRUE)
dev.off()
acNetFig <-paste0(outDir,SP,'_AcNetwork.png')
```
***Best acoustic network:***

![](`r acNetFig`)
<br> 

```{r plot visual network, eval = TRUE, message = FALSE, warning = FALSE, results = 'hide', echo = FALSE, fig.width = 14, fig.height = 8}

n2 = varUnits[n[model1.indices]]
n3 = c("SST","SSH","CHL","MLD","SAL","CUR","Upwell","-Eddy","+Eddy")
png(paste(outDir,SP,'_VisNetwork.png',sep=''), res = 300,width = 5, height = 4, units = "in")
par(mar=c(1,1,1,1),family = 'serif')
NNFitVals <- NULL
for (iN in c(1:trainRepeats)){
  NNFitVals[iN] <- nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iN]]$value
}
bestNetwork <- which.min(NNFitVals)
plot.nnet(nn_AcOnly[[best_VisOnly_ModelIndex]]$model[[bestNetwork]],x.lab = n3, y.lab = bquote(hat("D")),bias = F,cex=1.3,circle.col='gray',bord.col = 'darkgray', 
          neg.col = 'red',node.labs = FALSE,circle.cex = 3, alpha.val =.8, max.sp = TRUE)
dev.off()
visNetFig <-paste0(outDir,SP,'_VisNetwork.png')
```

***Best visual network:***

![](`r visNetFig`)
<br> 

# 3. Model Predictions

## 3.1 Temporal predictions

Predictions were made on the acoustic test dataset, and compared with actual observations for 2013. The predicted density of animals at each site was compared with the estimated daily density from the pasive acoustic record. 

<br>

### 3.1.1 Acoustic-only prediction
```{r Ac Temporal Predict, echo = FALSE, warning = FALSE, message = FALSE}
# Predict on acoustic test data, using acoustic only model for comparison...
allCovars <- NA
allCovars <- rbind(AcOnly_train_scaled,
                               AcOnly_test_scaled)
allCovars$fac2 <- c(Train_AcOnly.set$fac2[goodData_Ac],Test_AcOnly.set$fac2[goodData_Ac_test])

allCovars$date <- c(Train_AcOnly.set$date[goodData_Ac],Test_AcOnly.set$date[goodData_Ac_test])
compAcSet_MC_all <- which((allCovars$fac2)<=5)
compAcSet_GC_all <- which((allCovars$fac2)>5 & (allCovars$fac2)<=10)
compAcSet_DT_all <- which((allCovars$fac2)>10 &
                        (allCovars$fac2)<=16)
compAcSet_DC_all <- which((allCovars$fac2)>16 &
                        (allCovars$fac2)<=22)
compAcSet_MP_all <- which((allCovars$fac2)>22)
allObservations<-c(Train_AcOnly.set$Density[goodData_Ac],
                       Test_AcOnly.set$Density[goodData_Ac_test])
allTheDays = seq(min(Train_AcOnly.set$date),max(Test_AcOnly.set$date), by="days")

# Predict in time
dateTicks = as.POSIXct(c('2013-01-01 GMT','2013-04-01 GMT',
                         '2013-07-01 GMT','2013-10-01 GMT',
                         '2014-01-01 GMT'))
dateLabels = c('Jan. 2013','Apr. 2013','Jul. 2013','Oct 2013','Jan. 2014')

predAcOnly_MC <-NULL
predAcOnly_GC <-NULL
predAcOnly_DT <-NULL
predAcOnly_DC <-NULL
predAcOnly_MP <-NULL
reducedData_MC <- allCovars[compAcSet_MC_all,model1.indices]
predAcOnly_MC <- exp(unname(predict(nn_AcOnly[[best_AcOnly_ModelIndex]],
                         reducedData_MC))*log(covars_AcOnly_max.train['yAcOnly']))-1
predAcOnly_MC[predAcOnly_MC<0]=0

reducedData_GC <- allCovars[compAcSet_GC_all,model1.indices]
predAcOnly_GC <- exp(unname(predict(nn_AcOnly[[best_AcOnly_ModelIndex]],
                         reducedData_GC))*log(covars_AcOnly_max.train['yAcOnly']))-1
predAcOnly_GC[predAcOnly_GC<0]=0

reducedData_DT <- allCovars[compAcSet_DT_all,model1.indices]
predAcOnly_DT <- exp(unname(predict(nn_AcOnly[[best_AcOnly_ModelIndex]],
                         reducedData_DT))*log(covars_AcOnly_max.train['yAcOnly']))-1
predAcOnly_DT[predAcOnly_DT<0]=0

reducedData_DC <- allCovars[compAcSet_DC_all,model1.indices]
predAcOnly_DC <- exp(unname(predict(nn_AcOnly[[best_AcOnly_ModelIndex]],
                         reducedData_DC))*log(covars_AcOnly_max.train['yAcOnly']))-1
predAcOnly_DC[predAcOnly_DC<0]=0

reducedData_MP <- allCovars[compAcSet_MP_all,model1.indices]
predAcOnly_MP <- exp(unname(predict(nn_AcOnly[[best_AcOnly_ModelIndex]],
                         reducedData_MP))*log(covars_AcOnly_max.train['yAcOnly']))-1
predAcOnly_MP[predAcOnly_MP<0]=0

predVar_MC <- NULL
predVar_GC <- NULL
predVar_DT <- NULL
predVar_DC <- NULL
predVar_MP <- NULL
myYmax <- 125#ceiling(max(c(predAcOnly_MC,predAcOnly_GC,predAcOnly_DT),na.rm = TRUE))
for (iMod in c(1:trainRepeats)){
  
  predVar_MC[[iMod]] <- predict(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                             reducedData_MC)*
                             covars_AcOnly_max.train['yAcOnly']
  predVar_MC[[iMod]][predVar_MC[[iMod]]<0] = 0
  predVar_GC[[iMod]] <- predict(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                             reducedData_GC)*
                             covars_AcOnly_max.train['yAcOnly']
  predVar_GC[[iMod]][predVar_GC[[iMod]]<0] = 0
  predVar_DT[[iMod]] <- predict(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                             reducedData_DT)*
                             covars_AcOnly_max.train['yAcOnly']
  predVar_DT[[iMod]][predVar_DT[[iMod]]<0] = 0
  predVar_DC[[iMod]] <- predict(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                             reducedData_DC)*
                             covars_AcOnly_max.train['yAcOnly']
  predVar_DC[[iMod]][predVar_DC[[iMod]]<0] = 0
  predVar_MP[[iMod]] <- predict(nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                             reducedData_MP)*
                             covars_AcOnly_max.train['yAcOnly']
  predVar_MP[[iMod]][predVar_MP[[iMod]]<0] = 0 
}

# AcOnly_predictionSet <- data.frame(unique(Test_AcOnly.set$date[goodData_Ac_test]))
# AcOnlyGoodTimes <-  Test_AcOnly.set$date[goodData_Ac_test]
# colnames(AcOnly_predictionSet) <-"date"

n1MC <- length(predVar_MC[[1]])
predVar_MC_DF <- structure(predVar_MC, row.names = c(NA, -n1MC), class = "data.frame")

n1GC <- length(predVar_GC[[1]])
predVar_GC_DF <- structure(predVar_GC, row.names = c(NA, -n1GC), class = "data.frame")

n1DT <- length(predVar_DT[[1]])
predVar_DT_DF <- structure(predVar_DT, row.names = c(NA, -n1DT), class = "data.frame")

n1DC <- length(predVar_DC[[1]])
predVar_DC_DF <- structure(predVar_DC, row.names = c(NA, -n1DC), class = "data.frame")

n1MP <- length(predVar_MP[[1]])
predVar_MP_DF <- structure(predVar_MP, row.names = c(NA, -n1MP), class = "data.frame")

allCovars$observations <- allObservations
allCovars$observations_smooth <- rollmean(allObservations,k = 7,fill=NA)
allCovars$Legend <- "Predictions"
allCovars$DataGroup <- "Observations"
allCovars$DE <- "Density"


AcOnly_predictionSet <-  data.frame(allTheDays)
colnames(AcOnly_predictionSet) <-"date"
AcOnly_predictionSet$MC <- NA
AcOnly_predictionSet$predSd_MC <- NA
MC_times <- allCovars$date[compAcSet_MC_all]
m1 <- match(MC_times,allTheDays)
AcOnly_predictionSet$MC[m1] <-predAcOnly_MC
AcOnly_predictionSet$predSd_MC[m1] <- rowSds(data.matrix(predVar_MC_DF),na.rm=TRUE)#/sqrt(trainRepeats)
AcOnly_predictionSet$obs_MC_smooth <- NA
AcOnly_predictionSet$obs_MC_smooth[m1]<- allCovars$observations_smooth[compAcSet_MC_all]
AcOnly_predictionSet$obs_MC <- NA
AcOnly_predictionSet$obs_MC[m1]<- allCovars$observations[compAcSet_MC_all]

AcOnly_predictionSet$GC <- NA
AcOnly_predictionSet$predSd_GC <- NA
AcOnly_predictionSet$testObs_GC <-NA
GC_times <- allCovars$date[compAcSet_GC_all]
m2 <- match(GC_times,allTheDays)
AcOnly_predictionSet$GC[m2] <-predAcOnly_GC
AcOnly_predictionSet$predSd_GC[m2] <- rowSds(data.matrix(predVar_GC_DF),na.rm=TRUE)#/sqrt(trainRepeats)
AcOnly_predictionSet$obs_GC_smooth <- NA
AcOnly_predictionSet$obs_GC_smooth[m2]<- rollmean(allCovars$observations[compAcSet_GC_all],k = 7,fill=NA)
AcOnly_predictionSet$obs_GC <- NA
AcOnly_predictionSet$obs_GC[m2]<- allCovars$observations[compAcSet_GC_all]

AcOnly_predictionSet$DT <- NA
AcOnly_predictionSet$predSd_DT <- NA
AcOnly_predictionSet$testObs_DT <-NA
DT_times <- allCovars$date[compAcSet_DT_all]
m3 <- match(DT_times,allTheDays)
AcOnly_predictionSet$DT[m3] <-predAcOnly_DT
AcOnly_predictionSet$predSd_DT[m3] <- rowSds(data.matrix(predVar_DT_DF),na.rm=TRUE)#/sqrt(trainRepeats)
AcOnly_predictionSet$obs_DT_smooth <- NA
AcOnly_predictionSet$obs_DT_smooth[m3]<- rollmean(allCovars$observations[compAcSet_DT_all],k = 7,fill=NA)
AcOnly_predictionSet$obs_DT <- NA
AcOnly_predictionSet$obs_DT[m3]<- allCovars$observations[compAcSet_DT_all]

AcOnly_predictionSet$DC <- NA
AcOnly_predictionSet$predSd_DC <- NA
AcOnly_predictionSet$testObs_DC <-NA
DC_times <- allCovars$date[compAcSet_DC_all]
m4 <- match(DC_times,allTheDays)
AcOnly_predictionSet$DC[m4] <-predAcOnly_DC
AcOnly_predictionSet$predSd_DC[m4] <- rowSds(data.matrix(predVar_DC_DF),na.rm=TRUE)#/sqrt(trainRepeats)
AcOnly_predictionSet$obs_DC_smooth <- NA
AcOnly_predictionSet$obs_DC_smooth[m4]<- rollmean(allCovars$observations[compAcSet_DC_all],k = 7,fill=NA)
AcOnly_predictionSet$obs_DC <- NA
AcOnly_predictionSet$obs_DC[m4]<- allCovars$observations[compAcSet_DC_all]

AcOnly_predictionSet$MP <- NA
AcOnly_predictionSet$predSd_MP <- NA
AcOnly_predictionSet$testObs_MP <-NA
MP_times <- allCovars$date[compAcSet_MP_all]
m5 <- match(MP_times,allTheDays)
AcOnly_predictionSet$MP[m5] <-predAcOnly_MP
AcOnly_predictionSet$predSd_MP[m5] <- rowSds(data.matrix(predVar_MP_DF),na.rm=TRUE)#/sqrt(trainRepeats)
AcOnly_predictionSet$obs_MP_smooth <- NA
AcOnly_predictionSet$obs_MP_smooth[m5]<- rollmean(allCovars$observations[compAcSet_MP_all],k = 7,fill=NA)
AcOnly_predictionSet$obs_MP <- NA
AcOnly_predictionSet$obs_MP[m5]<- allCovars$observations[compAcSet_MP_all]

AcOnly_predictionSet$Legend1 <- "1 Observations"
AcOnly_predictionSet$StDev <- "Std. Error"
AcOnly_predictionSet$Legend <- "2 Observations (mean)"
AcOnly_predictionSet$LegendTest <- "3 Acoustic"
mcLabel <- grobTree(textGrob("MC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
gcLabel <- grobTree(textGrob("GC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
dtLabel <- grobTree(textGrob("DT", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
dcLabel <- grobTree(textGrob("DC", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
mpLabel <- grobTree(textGrob("MP", x=0.01,  y=0.90, hjust=0,
  gp=gpar(col="black", fontsize=13, fontface="bold")))
```


### 3.1.2 Visual-only prediction

```{r Vis Temporal Predict, warning = FALSE, echo = FALSE}
# Confusing, but acoustic only predictors are passed in to since
# we're predicting on the acoustic timeseries.
# Predict in time
predVisOnly_MC <- exp(predict(nn_VisOnly[[best_VisOnly_ModelIndex]],
                          reducedData_MC)*
                          log(covars_VisOnly_max.train['yVisOnly']))-1
predVisOnly_MC[predVisOnly_MC<0]=0

predVisOnly_GC <- exp(predict(nn_VisOnly[[best_VisOnly_ModelIndex]],
                          reducedData_GC)*
                          log(covars_VisOnly_max.train['yVisOnly']))-1
predVisOnly_GC[predVisOnly_GC<0]=0

predVisOnly_DT <- exp(predict(nn_VisOnly[[best_VisOnly_ModelIndex]],
                          reducedData_DT)*
                          log(covars_VisOnly_max.train['yVisOnly']))-1
predVisOnly_DT[predVisOnly_DT<0]=0

predVisOnly_DC <- exp(predict(nn_VisOnly[[best_VisOnly_ModelIndex]],
                          reducedData_DC)*
                          log(covars_VisOnly_max.train['yVisOnly']))-1
predVisOnly_DC[predVisOnly_DC<0]=0

predVisOnly_MP <- exp(predict(nn_VisOnly[[best_VisOnly_ModelIndex]],
                          reducedData_MP)*
                          log(covars_VisOnly_max.train['yVisOnly']))-1
predVisOnly_MP[predVisOnly_MP<0]=0



predVar_MC <- NULL
predVar_GC <- NULL
predVar_DT <- NULL
predVar_DC <- NULL
predVar_MP <- NULL
for (iMod in c(1:trainRepeats)){
  predVar_MC[[iMod]] <- predict(nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                             reducedData_MC)*
                             covars_VisOnly_max.train['yVisOnly']
  predVar_MC[[iMod]][predVar_MC[[iMod]]<0]=0
  predVar_GC[[iMod]] <- predict(nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                             reducedData_GC)*
                             covars_VisOnly_max.train['yVisOnly']
  predVar_GC[[iMod]][predVar_GC[[iMod]]<0]=0
  predVar_DT[[iMod]] <- predict(nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                             reducedData_DT)*
                             covars_VisOnly_max.train['yVisOnly']
  predVar_DT[[iMod]][predVar_DT[[iMod]]<0]=0
  predVar_DC[[iMod]] <- predict(nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                             reducedData_DC)*
                             covars_VisOnly_max.train['yVisOnly']
  predVar_DC[[iMod]][predVar_DC[[iMod]]<0]=0
  predVar_MP[[iMod]] <- predict(nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                             reducedData_MP)*
                             covars_VisOnly_max.train['yVisOnly']
  predVar_MP[[iMod]][predVar_MP[[iMod]]<0]=0

}
n1MC <- length(predVar_MC[[1]])
predVar_MC_DF <- structure(predVar_MC, row.names = c(NA, -n1MC), class = "data.frame")

n1GC <- length(predVar_GC[[1]])
predVar_GC_DF <- structure(predVar_GC, row.names = c(NA, -n1GC), class = "data.frame")

n1DT <- length(predVar_DT[[1]])
predVar_DT_DF <- structure(predVar_DT, row.names = c(NA, -n1DT), class = "data.frame")

n1DC <- length(predVar_DC[[1]])
predVar_DC_DF <- structure(predVar_DC, row.names = c(NA, -n1DC), class = "data.frame")

n1MP <- length(predVar_MP[[1]])
predVar_MP_DF <- structure(predVar_MP, row.names = c(NA, -n1MP), class = "data.frame")

VisOnly_predictionSet <- data.frame(allTheDays)
colnames(VisOnly_predictionSet) <-"date"

VisOnly_predictionSet$MC <- NA
VisOnly_predictionSet$predSd_MC <- NA
m1 <- match(MC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$MC[m1] <-predVisOnly_MC
VisOnly_predictionSet$predSd_MC[m1] <- rowSds(data.matrix(predVar_MC_DF),na.rm=TRUE)#/sqrt(trainRepeats)

VisOnly_predictionSet$GC <- NA
VisOnly_predictionSet$predSd_GC <- NA
m2 <- match(GC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$GC[m2] <-predVisOnly_GC
VisOnly_predictionSet$predSd_GC[m2] <- rowSds(data.matrix(predVar_GC_DF),na.rm=TRUE)#/sqrt(trainRepeats)

VisOnly_predictionSet$DT <- NA
VisOnly_predictionSet$predSd_DT <- NA
m3 <- match(DT_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$DT[m3] <-predVisOnly_DT
VisOnly_predictionSet$predSd_DT[m3] <- rowSds(data.matrix(predVar_DT_DF),na.rm=TRUE)#/sqrt(trainRepeats)

VisOnly_predictionSet$DC <- NA
VisOnly_predictionSet$predSd_DC <- NA
m4 <- match(DC_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$DC[m4] <-predVisOnly_DC
VisOnly_predictionSet$predSd_DC[m4] <- rowSds(data.matrix(predVar_DC_DF),na.rm=TRUE)#/sqrt(trainRepeats)

VisOnly_predictionSet$MP <- NA
VisOnly_predictionSet$predSd_MP <- NA
m5 <- match(MP_times,VisOnly_predictionSet$date)
VisOnly_predictionSet$MP[m5] <-predVisOnly_MP
VisOnly_predictionSet$predSd_MP[m5] <- rowSds(data.matrix(predVar_MP_DF),na.rm=TRUE)#/sqrt(trainRepeats)

VisOnly_predictionSet$Legend <- "Predictions - Train"
VisOnly_predictionSet$LegendTest <- "4 Predictions - Test"
```


<br>

**Predicted and observed encounter probabilities at passive acoustic monitoring sites:**

```{r,fig.height = 10, fig.width = 7, message = FALSE, warning = FALSE, echo = FALSE, eval = TRUE}
# par(mfrow = c(5,1),oma=c(3,0,5,0)),colour="#000099",colour="#CC0000"
p1 <- ggplot() +
  geom_rect(data =VisOnly_predictionSet, aes(xmin=date[731], xmax=date[1095], ymin=0, ymax=120), fill="gray85")+
  geom_col(data = AcOnly_predictionSet,
             aes(x = date, y = obs_MC,color = Legend1),alpha = 1,width = .1,size = .25,key_glyph = "rect")+
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = obs_MC_smooth,color = Legend),size = .5,key_glyph = "rect")+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=MC, color = LegendTest), size = .5,key_glyph = "rect") +
  geom_line(data = VisOnly_predictionSet,
            aes(x=date, y=MC, color = LegendTest),size = .5,key_glyph = "rect") +
  labs(y = " ", x = NULL)+coord_cartesian(ylim = c(0,120))+  theme_bw()+
  theme(legend.position=c(.90,.7),legend.title=element_blank(),
        legend.text = element_text(size = 6),axis.title.y = element_text(size = 8,),
        plot.margin = unit(c(0,0,10,9), "pt"),
        axis.text.x = element_blank(),
        legend.key=element_rect(fill=NA),
        legend.box.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt"))+  
  scale_color_manual(labels = c("Observations","Obs. (7-day smooth)","Model - Acoustic","Model - Visual"),
                     values= c("grey46","gray34","deepskyblue","red2"),
                     guide = guide_legend(keyheight = unit(1, units = "mm") , keywidth = unit(2, units = "mm")))+
  annotation_custom(mcLabel)

p2 <- ggplot() +
  geom_rect(data =VisOnly_predictionSet, aes(xmin=date[731], xmax=date[1095], ymin=0, ymax=120), fill="gray85")+
  geom_col(data = AcOnly_predictionSet,
             aes(x = date, y = obs_GC,color = Legend1),alpha = 1,width = .01,size = .25)+
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = obs_GC_smooth,color = Legend),size = .5)+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=GC, color = LegendTest), size = .5) +
  geom_path(data = VisOnly_predictionSet,
            aes(x=date, y=GC, color = LegendTest),size = .5) +
  labs(y = " ", x = NULL)+coord_cartesian(ylim = c(0,120))+
  scale_color_manual(labels = c("Observations","Obs. (7-day mean)","Model - Acoustic","Model - Visual"),
                     values= c("grey46","gray34","deepskyblue","red2"))+theme_bw()+
  theme(legend.position="none", axis.title.y = element_text(size = 8,),panel.spacing.y=unit(0, "lines"),plot.margin = unit(c(0,0,10,9), "pt"),axis.text.x = element_blank())+
  annotation_custom(gcLabel)

p3 <- ggplot() +
  geom_rect(data =VisOnly_predictionSet, aes(xmin=date[731], xmax=date[1095], ymin=0, ymax=120), fill="gray85")+
  geom_col(data = AcOnly_predictionSet,
             aes(x = date, y = obs_DT, color = Legend1),alpha = 1, width = .1,size = .25)+
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = obs_DT_smooth,color = Legend),size = .5)+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=DT, color = LegendTest), size = .5) +
  geom_path(data = VisOnly_predictionSet,
            aes(x=date, y=DT, color = LegendTest), size = .5) +
  scale_color_manual(labels = c("Observations","Obs. (7-day smooth)","Model - Acoustic","Model - Visual"),
                     values= c("grey46","gray34","deepskyblue","red2"))+theme_bw()+
  labs(y =" ", x = NULL)+theme_bw()+coord_cartesian(ylim = c(0,120))+
  theme(legend.position="none",axis.title.y = element_text(size = 8,),panel.spacing.y=unit(0, "lines"),plot.margin = unit(c(0,0,10,0), "pt"),axis.text.x = element_blank())+labs(y =bquote("Density (per 1000"~km^2~")"), x = NULL)+
  annotation_custom(dtLabel)

p4 <- ggplot() +
  geom_rect(data =VisOnly_predictionSet, aes(xmin=date[731], xmax=date[1095], ymin=0, ymax=120), fill="gray85")+
  geom_col(data = AcOnly_predictionSet,
             aes(x = date, y = obs_DC,color = Legend1),alpha = 1, width = .1,size = .25)+
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = obs_DC_smooth,color = Legend),size = .5)+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=DC, color = LegendTest), size = .5) +
  geom_path(data = VisOnly_predictionSet,
            aes(x=date, y=DC, color = LegendTest),size = .5) +
  labs(y = " ", x = NULL)+
  scale_color_manual(labels = c("Observations","Obs. (7-day smooth)","Model - Acoustic","Model - Visual"),
                     values= c("grey46","gray34","deepskyblue","red2"))+theme_bw()+
  theme(legend.position="none",axis.title.y = element_text(size = 8,),plot.margin = unit(c(0,0,10,9),"pt"),axis.text.x = element_blank())+coord_cartesian(ylim = c(0,120))+labs(y = " ")+
  annotation_custom(dcLabel)

p5 <- ggplot() +
  geom_rect(data =VisOnly_predictionSet, aes(xmin=date[731], xmax=date[1095], ymin=0, ymax=120), fill="gray85")+
  geom_col(data = AcOnly_predictionSet,
             aes(x = date, y = obs_MP,color = Legend1),alpha = 1, width = .1,size = .25)+
  geom_line(data = AcOnly_predictionSet,
             aes(x = date, y = obs_MP_smooth,color = Legend),size = .5)+
  geom_line(data = AcOnly_predictionSet,
            aes(x=date, y=MP, color = LegendTest), size = .5) +
  geom_path(data = VisOnly_predictionSet,
            aes(x=date, y=MP, color = LegendTest),size = .5) +
  labs(y = " ", x = NULL)+
  scale_color_manual(labels = c("Observations","Obs. (7-day smooth)","Model - Acoustic","Model - Visual"),
                     values= c("grey46","gray34","deepskyblue","red2"))+theme_bw()+
  theme(legend.position="none",axis.title.y = element_text(size = 8,),plot.margin = unit(c(0,0,0,9),"pt"))+coord_cartesian(ylim = c(0,120))+
  annotation_custom(mpLabel)




timeSeriesFig = paste(outDir,SP,'_Timeseries_Prediction_NN_Density.png',sep='')
png(timeSeriesFig, width = 6.6, height = 6.7, units = "in", res=600)

# 
multiplot(p1, p2, p3, p4, p5, cols = 1)
dev.off()
```

![](`r timeSeriesFig`)
<br> 

## 3.2 Spatial predictions

```{r load raster bricks, echo = FALSE}
load('F:/GRIIDC_inputs/2009_prediction_rasters_scaled.Rdata') 
```

Models were evaluated for summer (July 2009) and winter(January 2009) across the entire Gulf of Mexico (US EEZ beyond the 200m contour).

```{r Ac Spatial Predict, warning = FALSE, echo = FALSE}
### Acoustic Only spatial prediction

# set out of range values in rasters to NA
jan2009_rastersAc <- jan2009_rasters
july2009_rastersAc <- july2009_rasters

for (iR in model1.indices){
  paste(iR)
  thisVarName <- n[iR]
  paste(thisVarName)
  jan2009_rastersAc[[thisVarName]][jan2009_rastersAc[[thisVarName]]<
                              AcOnlyRangesMin[thisVarName]]<- NA
  jan2009_rastersAc[[thisVarName]][jan2009_rastersAc[[thisVarName]]>
                              AcOnlyRangesMax[thisVarName]]<- NA
  
  july2009_rastersAc[[thisVarName]][july2009_rastersAc[[thisVarName]]<
                              AcOnlyRangesMin[thisVarName]]<- NA
  july2009_rastersAc[[thisVarName]][july2009_rastersAc[[thisVarName]]>
                              AcOnlyRangesMax[thisVarName]]<- NA
}


jan2009_AcOnly_prediction <- (exp(raster::predict(jan2009_rastersAc,
                   nn_AcOnly[[best_AcOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_AcOnly_max.train['yAcOnly']))-1)/10
jan2009_AcOnly_prediction[jan2009_AcOnly_prediction<0]=0
# make prediction including out of range items using unpruned raster
jan2009_AcOnly_prediction_IncludingOutsideObs <- (exp(raster::predict(jan2009_rasters,
                   nn_AcOnly[[best_AcOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_AcOnly_max.train['yAcOnly']))-1)/10
jan2009_AcOnly_prediction_IncludingOutsideObs[jan2009_AcOnly_prediction_IncludingOutsideObs
                                              <0]=0

july2009_AcOnly_prediction <- (exp(raster::predict(july2009_rastersAc,
                   nn_AcOnly[[best_AcOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_AcOnly_max.train['yAcOnly']))-1)/10
july2009_AcOnly_prediction[july2009_AcOnly_prediction<0]=0
# make prediction including out of range items using unpruned raster
july2009_AcOnly_prediction_IncludingOutsideObs <- (exp(raster::predict(july2009_rasters,
                   nn_AcOnly[[best_AcOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_AcOnly_max.train['yAcOnly']))-1)/10
july2009_AcOnly_prediction_IncludingOutsideObs[july2009_AcOnly_prediction_IncludingOutsideObs
                                              <0]=0


# compute for each iteration to generate variability index
perModel_jan2009_AcOnly <- vector('list',length = trainRepeats)
perModel_july2009_AcOnly <- vector('list',length = trainRepeats)
for (iMod in c(1:trainRepeats)){
  perModel_jan2009_AcOnly[iMod] <- raster::predict(jan2009_rastersAc,                                             nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                                             na.action = na.pass)*covars_AcOnly_max.train['yAcOnly']/10
  perModel_jan2009_AcOnly[[iMod]][perModel_jan2009_AcOnly[[iMod]]<0]<-0
  perModel_july2009_AcOnly[iMod] <- raster::predict(july2009_rastersAc,                                             nn_AcOnly[[best_AcOnly_ModelIndex]]$model[[iMod]],
                                             na.action = na.pass)*covars_AcOnly_max.train['yAcOnly']/10
  perModel_july2009_AcOnly[[iMod]][perModel_july2009_AcOnly[[iMod]]<0]<-0
}
```


```{r Vis Spatial Predict, warning = FALSE, echo = FALSE}
### Visual Only spatial prediction

jan2009_rastersVis <- jan2009_rasters
july2009_rastersVis <- july2009_rasters

for (iR in model1.indices){
  thisVarName <- n[iR]
  jan2009_rastersVis[[thisVarName]][jan2009_rastersVis[[thisVarName]]<
                              VisOnlyRangesMin[thisVarName]]<- NA
  jan2009_rastersVis[[thisVarName]][jan2009_rastersVis[[thisVarName]]>
                              VisOnlyRangesMax[thisVarName]]<- NA
  
  july2009_rastersVis[[thisVarName]][july2009_rastersVis[[thisVarName]]<
                              VisOnlyRangesMin[thisVarName]]<- NA
  july2009_rastersVis[[thisVarName]][july2009_rastersVis[[thisVarName]]>
                              VisOnlyRangesMax[thisVarName]]<- NA
}

jan2009_VisOnly_prediction <- (exp(raster::predict(jan2009_rastersVis,
         nn_VisOnly[[best_VisOnly_ModelIndex]],na.action = na.pass)*
         log(covars_VisOnly_max.train['yVisOnly']))-1)/10
jan2009_VisOnly_prediction[jan2009_VisOnly_prediction<0]=0
# make prediction including out of range items using unpruned raster
jan2009_VisOnly_prediction_IncludingOutsideObs <- (exp(raster::predict(jan2009_rasters,
                   nn_VisOnly[[best_VisOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_VisOnly_max.train['yVisOnly']))-1)/10
jan2009_VisOnly_prediction_IncludingOutsideObs[jan2009_VisOnly_prediction_IncludingOutsideObs
                                              <0]=0

july2009_VisOnly_prediction <- (exp(raster::predict(july2009_rastersVis,
         nn_VisOnly[[best_VisOnly_ModelIndex]],
         na.action = na.pass)*log(covars_VisOnly_max.train['yVisOnly']))-1)/10
july2009_VisOnly_prediction[july2009_VisOnly_prediction<0]=0
# make prediction including out of range items using unpruned raster
july2009_VisOnly_prediction_IncludingOutsideObs <- (exp(raster::predict(july2009_rasters,
                   nn_VisOnly[[best_VisOnly_ModelIndex]],
                   na.action = na.pass)*log(covars_VisOnly_max.train['yVisOnly']))-1)/10
july2009_VisOnly_prediction_IncludingOutsideObs[july2009_VisOnly_prediction_IncludingOutsideObs
                                              <0]=0


perModel_jan2009_VisOnly <- vector('list',length = trainRepeats)
perModel_july2009_VisOnly <- vector('list',length = trainRepeats)
for (iMod in c(1:trainRepeats)){
  perModel_jan2009_VisOnly[iMod] <- (exp(raster::predict(jan2009_rastersVis,
                             nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                                             na.action = na.pass)*log(covars_VisOnly_max.train['yVisOnly']))-1)/10
  perModel_jan2009_VisOnly[[iMod]][perModel_jan2009_VisOnly[[iMod]]<0]<-0

  perModel_july2009_VisOnly[iMod] <- (exp(raster::predict(july2009_rastersVis,
                 nn_VisOnly[[best_VisOnly_ModelIndex]]$model[[iMod]],
                 na.action = na.pass)*log(covars_VisOnly_max.train['yVisOnly']))-1)/10
  perModel_july2009_VisOnly[[iMod]][perModel_july2009_VisOnly[[iMod]]<0]<-0
}
```




```{r wrangle projections, message = FALSE, warning = FALSE, echo = FALSE, results = 'hide'}
# Wrangle projections for mapping:

predTemplate <-raster('F:/GRIIDC_inputs/RefRaster.tif')
map_proj <- crs(predTemplate)
crop_limits <- readOGR('F:/GRIIDC_inputs/prediction_polygon.shp',verbose=FALSE)
crop_limits_proj <- spTransform(crop_limits, CRSobj = map_proj)

# Acoustic
jan2009_AcOnly_prediction_crop <- mask(jan2009_AcOnly_prediction,crop_limits_proj)
july2009_AcOnly_prediction_crop <-
  mask(july2009_AcOnly_prediction,crop_limits_proj)
jan2009_AcOnly_map_probSee <- jan2009_AcOnly_prediction_crop*visG0*visDetProb
july2009_AcOnly_map_probSee <- july2009_AcOnly_prediction_crop*visG0*visDetProb

perModel_jan2009_AcOnly_crop <- vector('list',length = trainRepeats)
perModel_july2009_AcOnly_crop <- vector('list',length = trainRepeats)
for (iMod in c(1:trainRepeats)){
  perModel_jan2009_AcOnly_crop[[iMod]]  <- mask(perModel_jan2009_AcOnly[[iMod]],crop_limits_proj)
  perModel_july2009_AcOnly_crop[[iMod]]  <- mask(perModel_july2009_AcOnly[[iMod]],crop_limits_proj)
}

predSTD_jan2009_AcOnly_crop <- calc(stack(perModel_jan2009_AcOnly_crop),fun=std_err)/10
predSTD_july2009_AcOnly_crop <- calc(stack(perModel_july2009_AcOnly_crop),fun=std_err)/10

# Visual
jan2009_VisOnly_prediction_crop <- 
  mask(jan2009_VisOnly_prediction,crop_limits_proj)
july2009_VisOnly_prediction_crop <- mask(july2009_VisOnly_prediction,crop_limits_proj)
jan2009_VisOnly_map_probSee <- jan2009_VisOnly_prediction_crop*visG0*visDetProb
july2009_VisOnly_map_probSee <- july2009_VisOnly_prediction_crop*visG0*visDetProb

perModel_jan2009_VisOnly_crop <- vector('list',length = trainRepeats)
perModel_july2009_VisOnly_crop <- vector('list',length = trainRepeats)
for (iMod in c(1:trainRepeats)){
  perModel_jan2009_VisOnly_crop[[iMod]]  <- mask(perModel_jan2009_VisOnly[[iMod]], crop_limits_proj)
  perModel_july2009_VisOnly_crop[[iMod]]  <- mask(perModel_july2009_VisOnly[[iMod]], crop_limits_proj)
}
predSTD_jan2009_VisOnly_crop <- calc(stack(perModel_jan2009_VisOnly_crop),fun=std_err)/10

predSTD_july2009_VisOnly_crop <- calc(stack(perModel_july2009_VisOnly_crop),fun=std_err)/10

```


Each grid cell in the following maps represents a 10x10 km square. Densities are therefore shown as estimated number of animals per 100 km^2^.

<br>

### 3.2.1 Summer 2009 predictions

**Summer 2009 predicted distribution and test sightings:**


```{r leaflet summer, message = FALSE, warning = FALSE, echo = FALSE}
# Display summer (July 2009) map:
maxColorSummer <- ceiling(max(c(july2009_AcOnly_prediction_crop@data@max,
               july2009_VisOnly_prediction_crop@data@max))*10)/10
             
               
palSummer <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColorSummer), 
                    na.color = 'transparent')
GU2009Effort <- readOGR('F:/GRIIDC_inputs/GU_Effort_Merge_clip_Project.shp',verbose=FALSE)
GU2009EffortLines <- sp::spTransform(GU2009Effort, CRSobj = CRS('+init=epsg:4326'))

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(july2009_AcOnly_prediction_crop, colors = palSummer,
                 opacity = 0.8, group = 'Acoustic July 2009') %>%
  addRasterImage(july2009_VisOnly_prediction_crop, colors = palSummer,
                 opacity = 0.8, group = 'Visual July 2009') %>%
  addPolylines(data = GU2009EffortLines,
               group ='Visual Effort (Summer 2009)', 
               opacity = 1,
               color = "black", weight = 2)%>%
  addCircleMarkers(data = sightingsTest, lng = ~ long, lat = ~ lat,
                 color = "black",
                 stroke = TRUE, fillOpacity = 0.8,radius = 6,
                 group = 'Test Sightings (Summer 2009)') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%

  addLegend(pal = palSummer, values = c(0,maxColorSummer),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic July 2009','Visual July 2009'),
    overlayGroups = c('Test Sightings (Summer 2009)',
                      'Visual Effort (Summer 2009)'),
    options = layersControlOptions(collapsed = FALSE)
  )
map

```

```{r plot best summer map, eval = TRUE, echo = FALSE, message = FALSE, results = 'hide',warning = FALSE}
png(paste(outDir,SP,'_summer2009maps_NN_density.png',sep=''), width = 6, height = 7, units = 'in',res = 600)

# plot best summer map for publication
sightShape = SpatialPoints(sightingsTest[c(2,1)],proj4string =  crs(GU2009EffortLines))
harpShape = SpatialPoints(HARPsites[c(1,8,14),c(2,1)],proj4string =  
                            crs(GU2009EffortLines))
crop_limits_Reproj = spTransform(crop_limits_proj,crs(GU2009EffortLines))
myColormap = c("#0000FF", "#00FFFF", "#80FF80", "#FFFF00","#FFF000", "#FFF000", "#FF0000", "#FF0000", "#FF0000", "#F00000")

AcMapSummer = tm_shape(july2009_AcOnly_prediction_crop)+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,title = expression("Animals/100"~km^{2}),legend.reverse = TRUE)+ 
  tm_legend(legend.title.size = .9,legend.position = c("RIGHT","TOP"))+
  tm_shape(crop_limits_Reproj)+tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = .5, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = .4, alpha = .75)

VisMapSummer = tm_shape(july2009_VisOnly_prediction_crop)+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,title = expression("Animals/100"~km^{2}),legend.reverse = TRUE)+ 
  tm_legend(legend.title.size = .9,legend.position = c("RIGHT","TOP"))+
  tm_shape(crop_limits_Reproj)+tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = .5, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = .4, alpha = .75)

 tmap_arrange(AcMapSummer,VisMapSummer,ncol = 1, nrow = 2, outer.margins = 0.05)
 
 dev.off()
```

**Summer 2009 prediction uncertainty:**
```{r leaflet summer uncert, message = FALSE, warning = FALSE, echo = FALSE}
maxColorUncert <- ceiling(max(c(predSTD_july2009_AcOnly_crop@data@max,
               predSTD_july2009_VisOnly_crop@data@max))*100)/100
palUncert <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColorUncert), 
                    na.color = 'transparent')
# Display summer (July 2009) map:

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(predSTD_july2009_AcOnly_crop, colors = palUncert,
                 opacity = 0.8, group = 'Acoustic July 2009') %>%
  addRasterImage(predSTD_july2009_VisOnly_crop, colors = palUncert,
                 opacity = 0.8, group = 'Visual July 2009') %>%
  addLegend(pal = palUncert, values = c(0,maxColorUncert),
    title = 'STD(Estimated Density)',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic July 2009','Visual July 2009'),
    options = layersControlOptions(collapsed = FALSE)
  )
map
```

<br>  


### 3.2.2 Winter 2009 predictions

**Winter 2009 predicted distribution:**

```{r leaflet winter, message = FALSE, warning = FALSE, echo = FALSE}
# Display winter (January 2009) map:
maxColorWinter <- ceiling(max(c(jan2009_AcOnly_prediction_crop@data@max,
               jan2009_VisOnly_prediction_crop@data@max))*10)/10
               
palWinter <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColorWinter), 
                    na.color = 'transparent')
map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(jan2009_AcOnly_prediction_crop, colors = palWinter,
                 opacity = 0.8, group = 'Acoustic Jan. 2009') %>%
  addRasterImage(jan2009_VisOnly_prediction_crop, colors = palWinter,
                 opacity = 0.8, group = 'Visual Jan. 2009') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat) %>%
  addLegend(pal = palWinter, values = c(0,maxColorWinter),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic Jan. 2009','Visual Jan. 2009'),
    options = layersControlOptions(collapsed = FALSE)
  )
map

```

**Winter 2009 prediction uncertainty:**
```{r leaflet winter uncert, message = FALSE, warning = FALSE, echo = FALSE}
# Display summer (July 2009) map:

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(predSTD_jan2009_AcOnly_crop, colors = palUncert,
                 opacity = 0.8, group = 'Acoustic Jan. 2009') %>%
  addRasterImage(predSTD_jan2009_VisOnly_crop, colors = palUncert,
                 opacity = 0.8, group = 'Visual Jan. 2009') %>%
  addLegend(pal = palUncert, values = c(0,maxColorUncert),
    title = 'STD(Estimated Density)',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Acoustic Jan. 2009','Visual Jan. 2009'),
    options = layersControlOptions(collapsed = FALSE)
  )
map
```

<br>

### 3.3.3 How does hidden layer size change spatial predictions?

```{r look at effect of hidden layer on spatial prediction, width = 60, height = 30, message = FALSE, warning = FALSE, echo = FALSE}
nModels = length(layerSizeList)

july2009_prediction_hidden <- vector('list',length = nModels)

for (iP in c(1:nModels)){
     july2009_prediction_hidden[[iP]] <- mask((exp(raster::predict(july2009_rasters,
                   nn_AcOnly[[iP]],
                   na.action = na.pass)*log(covars_AcOnly_max.train['yAcOnly']))-1)/10,
                   crop_limits_proj)
}

maxVal = maxValue(july2009_prediction_hidden[[nModels]])
palSummer2 <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxVal), 
                    na.color = 'transparent')

# Display winter (January 2009) map:
map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(july2009_prediction_hidden[[1]], colors = palSummer2,
                 opacity = 0.8, group = '4 nodes') %>%
  addRasterImage(july2009_prediction_hidden[[2]], colors = palSummer2,
                  opacity = 0.8, group = '6 nodes') %>%
  addRasterImage(july2009_prediction_hidden[[3]], colors = palSummer2,
                  opacity = 0.8, group = '8 nodes') %>%
  addRasterImage(july2009_prediction_hidden[[4]], colors = palSummer2,
                opacity = 0.8, group = '10 nodes') %>%
  addRasterImage(july2009_prediction_hidden[[5]], colors = palSummer2,
                opacity = 0.8, group = '12 nodes') %>%
  addRasterImage(july2009_prediction_hidden[[6]], colors = palSummer2,
                opacity = 0.8, group = '14 nodes') %>%
  addLegend(pal = palSummer2, values = c(0,maxVal),
    title = 'Density',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('4 nodes','6 nodes','8 nodes',
                   '10 nodes','12 nodes','14 nodes'),
    options = layersControlOptions(collapsed = FALSE)
  )
map

```

```{r plot best summer map hidden layer, echo = FALSE, message = TRUE, results = 'hide',warning = FALSE}
# plot best summer map for publication
png(paste(outDir,SP,'_summer2009maps_NN_density_HiddenLayerEffect.png',sep=''), width = 6, height = 4, units = 'in',res = 600)

# plot best summer map for publication
sightShape = SpatialPoints(sightingsTest[c(2,1)],proj4string = crs(GU2009EffortLines))
harpShape = SpatialPoints(HARPsites[c(1,8,14),c(2,1)],proj4string =  
                            crs(GU2009EffortLines))
crop_limits_Reproj = spTransform(crop_limits_proj,crs(GU2009EffortLines))

AcOnlyMap1 = tm_shape(july2009_prediction_hidden[[1]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,title = expression("Animals/100"~km^{2}),legend.reverse = TRUE)+tm_layout(panel.labels="4 Nodes",panel.label.size=.6,legend.position = c(0.76,0.35))+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)+
  tm_legend(legend.height = .5,legend.title.size	
 = .9)

AcOnlyMap2 = tm_shape(july2009_prediction_hidden[[2]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,legend.show = FALSE)+  tm_layout(panel.labels="6 Nodes",panel.label.size=.6)+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)

AcOnlyMap3 = tm_shape(july2009_prediction_hidden[[3]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,legend.show = FALSE)+ tm_layout(panel.labels="8 Nodes",panel.label.size=.6,legend.position = c(0.89,0.02))+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)

AcOnlyMap4 = tm_shape(july2009_prediction_hidden[[4]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,legend.show = FALSE)+ tm_layout(panel.labels="10 Nodes",panel.label.size=.6)+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)

AcOnlyMap5 = tm_shape(july2009_prediction_hidden[[5]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,legend.show = FALSE)+tm_layout(panel.labels="12 Nodes",panel.label.size=.6)+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)

AcOnlyMap6 = tm_shape(july2009_prediction_hidden[[6]])+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,legend.show = FALSE)+tm_layout(panel.labels="14 Nodes",panel.label.size=.6)+
  tm_shape(crop_limits_Reproj)+
  tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = 0.2, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = 0.2, alpha = .75)
tmap_arrange(AcOnlyMap1, AcOnlyMap2, AcOnlyMap3, AcOnlyMap4, AcOnlyMap5, AcOnlyMap6, ncol = 2, nrow = 3)
 
 dev.off()
```

```{r plot best summer uncert map, echo = FALSE, message = FALSE, results = 'hide',warning = FALSE}
# plot best summer map for publication
png(paste(outDir,SP,'_summer2009maps_NN_se_density.png',sep=''), width = 6, height = 7, units = 'in',res = 600)

maxColorSE <- ceiling(max(c(predSTD_july2009_AcOnly_crop@data@max,
               predSTD_july2009_VisOnly_crop@data@max))*10)/10
# plot best summer map for publication
sightShape = SpatialPoints(sightingsTest[c(2,1)],proj4string =  crs(GU2009EffortLines))
harpShape = SpatialPoints(HARPsites[c(1,8,14),c(2,1)],proj4string =  
                            crs(GU2009EffortLines))
crop_limits_Reproj = spTransform(crop_limits_proj,crs(GU2009EffortLines))

AcMapSummer = tm_shape(predSTD_july2009_AcOnly_crop)+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,title = "SE(Density)",legend.reverse = TRUE)+ 
  tm_legend(legend.title.size = .9,legend.position = c("RIGHT","TOP"))+
  tm_shape(crop_limits_Reproj)+tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = .5, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = .4, alpha = .75)

VisMapSummer = tm_shape(predSTD_july2009_VisOnly_crop)+tm_raster(palette = matlab.like2(5),colorNA = NULL,style = "cont",midpoint = maxColorSummer/2,title = "SE(Density)",legend.reverse = TRUE)+ 
  tm_legend(legend.title.size = .9,legend.position = c("RIGHT","TOP"))+
  tm_shape(crop_limits_Reproj)+tm_borders(lty = 1)+
  tm_shape(GU2009EffortLines)+tm_lines()+
  tm_shape(harpShape)+tm_symbols(col = "orange", border.col = "black",size = .5, alpha = 1,shape = 24)+
  tm_shape(sightShape)+tm_symbols(col = "black", border.col = "white",shape=21,size = .4, alpha = .75)

 tmap_arrange(AcMapSummer,VisMapSummer,ncol = 1, nrow = 3, outer.margins = 0.05)
 
 dev.off()
```

# 4. Monthly model predictions

Spatial model predictions were generated using climatological means of oceanographic variables, averaged by month between 2003 and 2015.


```{r evaluate climatology-based models, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}

load('F:/GRIIDC_inputs/climatology_rasters_scaled.Rdata') 
monthNum <-c('01','02','03','04','05','06','07','08','09','10','11','12')
monthStr<-c('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec')

climatePrediction <- vector('list',length = 12)
mapClimatePrediction <- vector('list',length = 12)

for (iM in 1:length(monthStr)){
  climatePrediction[[iM]] <- raster::predict(raster_set[[iM]],nn_AcOnly[[best_AcOnly_ModelIndex]],
           na.action = na.pass)*covars_AcOnly_max.train['yAcOnly']/10
  climatePrediction[[iM]][climatePrediction[[iM]]<0]<-0
                          
  mapClimatePrediction[[iM]] <- mask(climatePrediction[[iM]], crop_limits_proj)  
  # output raster to geotiff
  rasterImageFileName = paste0(savePath,'/climatology_predictions/', SP,'_',monthStr[iM],'NNet_mean_density.tif')
  writeRaster(mapClimatePrediction[[iM]],filename = rasterImageFileName, format="GTiff",overwrite = TRUE)
  xyMap <-projectRaster((mapClimatePrediction[[iM]]),crs = CRS('+proj=longlat +dateum=WGS84'))

  # # ouput raster to kml
  kmlImageFileName = paste0(savePath,'/climatology_predictions/', SP,'_',monthStr[iM],'NNet_mean_density.kml')
  KML(xyMap,file = kmlImageFileName, col=matlab.like2(32),overwrite = TRUE)
}
  
```

```{r plot climatologies, eval = TRUE, message = FALSE, warning = FALSE, echo = FALSE}
maxColor <- ceiling(max(c(mapClimatePrediction[[1]]@data@max,
                mapClimatePrediction[[3]]@data@max,
                mapClimatePrediction[[5]]@data@max,
                mapClimatePrediction[[7]]@data@max,
                mapClimatePrediction[[9]]@data@max,
                mapClimatePrediction[[11]]@data@max))*10)/10

pal <- colorNumeric(palette = matlab.like2(5),
                    domain=c(0,maxColor), 
                    na.color = 'transparent')

map <- leaflet(width="100%") %>%  setView(lng = -88.8, lat = 27.0, zoom = 6)%>%
  addProviderTiles(providers$Esri.OceanBasemap) %>%
  addRasterImage(mapClimatePrediction[[1]] , colors = pal,
                 opacity = 0.8, group = 'Jan.') %>%
  addRasterImage(mapClimatePrediction[[3]] , colors = pal,
                 opacity = 0.8, group = 'March') %>%
  addRasterImage(mapClimatePrediction[[5]] , colors = pal,
                 opacity = 0.8, group = 'May') %>%
  addRasterImage(mapClimatePrediction[[7]] , colors = pal,
                 opacity = 0.8, group = 'July') %>%
  addRasterImage(mapClimatePrediction[[9]] ,colors = pal,
                 opacity = 0.8, group = 'Sept.') %>%
  addRasterImage(mapClimatePrediction[[11]] ,colors = pal,
                 opacity = 0.8, group = 'Nov.') %>%
  addMarkers(data = HARPsites, lng = ~ long, lat = ~ lat,
             group = "HARP Locations") %>%
  addLegend(pal = pal, values = c(0,maxColor),
    title = 'Est. Density <br> per 100 km^2',position = "bottomleft") %>%
  addLayersControl(
    baseGroups = c('Jan.','March','May',
                   'July','Sept.','Nov.'),
    overlayGroups = c('HARP Locations'),
    options = layersControlOptions(collapsed = FALSE)
  )
map
```
